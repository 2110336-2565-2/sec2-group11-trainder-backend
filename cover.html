
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>configs: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">trainder-api/configs/env.go (50.0%)</option>
				
				<option value="file1">trainder-api/configs/setup.go (79.2%)</option>
				
				<option value="file2">trainder-api/controllers/auth_controller.go (0.0%)</option>
				
				<option value="file3">trainder-api/controllers/booking_controller.go (0.0%)</option>
				
				<option value="file4">trainder-api/controllers/chat_controller.go (0.0%)</option>
				
				<option value="file5">trainder-api/controllers/image_controller.go (0.0%)</option>
				
				<option value="file6">trainder-api/controllers/payment_controller.go (0.0%)</option>
				
				<option value="file7">trainder-api/controllers/trainer_controller.go (0.0%)</option>
				
				<option value="file8">trainder-api/controllers/user_controller.go (0.0%)</option>
				
				<option value="file9">trainder-api/docs/docs.go (100.0%)</option>
				
				<option value="file10">trainder-api/main.go (0.0%)</option>
				
				<option value="file11">trainder-api/middlewares/auth_middleware.go (0.0%)</option>
				
				<option value="file12">trainder-api/models/auth_model.go (0.0%)</option>
				
				<option value="file13">trainder-api/models/booking_model.go (0.0%)</option>
				
				<option value="file14">trainder-api/models/chat_model.go (0.0%)</option>
				
				<option value="file15">trainder-api/models/image_model.go (0.0%)</option>
				
				<option value="file16">trainder-api/models/payment_model.go (0.0%)</option>
				
				<option value="file17">trainder-api/models/trainer_model.go (13.5%)</option>
				
				<option value="file18">trainder-api/models/user_model.go (0.0%)</option>
				
				<option value="file19">trainder-api/routes/auth_routes.go (0.0%)</option>
				
				<option value="file20">trainder-api/routes/protected_routes.go (0.0%)</option>
				
				<option value="file21">trainder-api/utils/inits/db_setup.go (0.0%)</option>
				
				<option value="file22">trainder-api/utils/tokens/tokens.go (0.0%)</option>
				
				<option value="file23">trainder-api/ws/client.go (0.0%)</option>
				
				<option value="file24">trainder-api/ws/hub.go (0.0%)</option>
				
				<option value="file25">trainder-api/ws/ws_handler.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package configs

import (
        "log"
        "os"
        "strconv"

        "github.com/joho/godotenv"
)

func loadDotEnv() <span class="cov10" title="7">{
        env := os.Getenv("TRAINDER_DO_NOT_USE_DOTENV")
        // if flag not set load .env file
        if env == "" </span><span class="cov10" title="7">{
                if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                        log.Fatal("Error loading .env file")
                }</span>
        }
}

func EnvMongoURI() string <span class="cov1" title="1">{
        loadDotEnv()
        return os.Getenv("MONGO_URI")
}</span>

func EnvMongoDBName() string <span class="cov7" title="4">{
        loadDotEnv()
        return os.Getenv("MONGO_DATABASE_NAME")
}</span>

func EnvTokenLifeSpan() (tokenLifespan int, err error) <span class="cov0" title="0">{
        loadDotEnv()
        tokenLifespan, err = strconv.Atoi(os.Getenv("TOKEN_HOUR_LIFESPAN"))
        return tokenLifespan, err
}</span>

func EnvApiSecret() string <span class="cov0" title="0">{
        loadDotEnv()
        return os.Getenv("API_SECRET")
}</span>

func EnvInitRootPassword() string <span class="cov0" title="0">{
        loadDotEnv()
        env := os.Getenv("INIT_ROOT_PASSWORD")
        if env == "" </span><span class="cov0" title="0">{
                log.Fatal("Root password cannot be empty")
        }</span>
        <span class="cov0" title="0">return env</span>
}

func EnvOmisePublicKey() string <span class="cov1" title="1">{
        loadDotEnv()
        return os.Getenv("OMISE_PUBLIC_KEY")
}</span>

func EnvOmiseSecretKey() string <span class="cov1" title="1">{
        loadDotEnv()
        return os.Getenv("OMISE_SECRET_KEY")
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package configs

import (
        "context"
        "fmt"
        "log"
        "time"

        "github.com/omise/omise-go"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/gridfs"
        "go.mongodb.org/mongo-driver/mongo/options"
)

func ConnectDB() *mongo.Client <span class="cov1" title="1">{
        client, err := mongo.NewClient(options.Client().ApplyURI(EnvMongoURI()))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov1" title="1">ctx, _ := context.WithTimeout(context.Background(), 10*time.Second)
        err = client.Connect(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov1" title="1">err = client.Ping(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov1" title="1">fmt.Println("Connected to MongoDB")
        return client</span>
}
func CreateGridFSBucket(client *mongo.Client) *gridfs.Bucket <span class="cov1" title="1">{

        db := client.Database(EnvMongoDBName())

        // Create a new GridFS bucket
        bucket, err := gridfs.NewBucket(
                db,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov1" title="1">fmt.Println("Create a new GridFS bucket")
        return bucket</span>
}

var DB *mongo.Client = ConnectDB()
var Bucket *gridfs.Bucket = CreateGridFSBucket(DB)

func GetCollection(client *mongo.Client, collectionName string) *mongo.Collection <span class="cov10" title="3">{
        collection := client.Database(EnvMongoDBName()).Collection(collectionName)
        return collection
}</span>

func ConnectOmise() *omise.Client <span class="cov1" title="1">{
        client, e := omise.NewClient(EnvOmisePublicKey(), EnvOmiseSecretKey())
        if e != nil </span><span class="cov0" title="0">{
                log.Fatal(e)
        }</span>
        <span class="cov1" title="1">return client</span>
}

var OmiseClient *omise.Client = ConnectOmise()
</pre>
		
		<pre class="file" id="file2" style="display: none">package controllers

import (
        "net/http"
        "trainder-api/models"
        "trainder-api/responses"

        "github.com/gin-gonic/gin"
)

type RegisterInput struct {
        Username    string  `json:"username" binding:"required"`
        Password    string  `json:"password" binding:"required"`
        UserType    string  `json:"usertype" binding:"required"`
        Firstname   string  `json:"firstname" binding:"required"`
        Lastname    string  `json:"lastname" binding:"required"`
        Birthdate   string  `json:"birthdate" binding:"required"`
        CitizenId   string  `json:"citizenId" binding:"required"`
        Gender      string  `json:"gender" binding:"required"`
        PhoneNumber string  `json:"phoneNumber" binding:"required"`
        Address     string  `json:"address" binding:"required"`
        AvatarUrl   string  `json:"avatarUrl"`
        Lat         float64 `json:"lat" binding:"required"`
        Lng         float64 `json:"lng" binding:"required"`
}
type LoginInput struct {
        Username string `json:"username" binding:"required"`
        Password string `json:"password" binding:"required"`
}

// @Summary                Register user
// @Description        Register with username,password,UserType ["trainer","trainee"],Firstname,Lastname,Birthdate ("yyyy-mm-dd"),CitizenId (len == 13),Gender ["Male","Female","Other"],PhoneNumber (len ==10),Address,SubAddress
// @Tags                authentication
// @ID                        register-user
// @Accept                json
// @Produce                json
// @Param                json_in_ginContext        body                RegisterInput        true        "put register input and pass to gin.Context"
// @Success                200                                        {object}        responses.RegisterResponse
// @Router                /register [post]
func Register() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{

                var input RegisterInput
                if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.RegisterResponse{Status: http.StatusBadRequest, Message: "input missing"})
                        return
                }</span>
                <span class="cov0" title="0">profileErr := models.ProfileConditionCheck(input.Firstname, input.Lastname, input.Birthdate, input.CitizenId, input.Gender, input.PhoneNumber)
                if profileErr != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.RegisterResponse{
                                Status:  http.StatusBadRequest,
                                Message: profileErr.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">userTypeErr := models.UserTypeCheck(input.UserType)
                if userTypeErr != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.RegisterResponse{
                                Status:  http.StatusBadRequest,
                                Message: userTypeErr.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">_, err := models.CreateUser(input.Username, input.Password, input.UserType, input.Firstname, input.Lastname, input.Birthdate, input.CitizenId, input.Gender, input.PhoneNumber, input.Address, input.AvatarUrl, input.Lat, input.Lng)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, responses.RegisterResponse{Status: http.StatusInternalServerError, Message: err.Error()})
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusCreated, responses.RegisterResponse{Status: http.StatusCreated, Message: "registration success!"})</span>
        }
}

// Login godoc
//
//        @Summary                Login
//        @Description        login with username and password
//        @Tags                        authentication
//        @Accept                        json
//        @Produce                json
//        @Param                        json_in_ginContext        body                LoginInput        true        "put login input and pass to  gin.Context"
//        @Success                200                                        {object}        responses.LoginResponse
//        @Router                        /login [post]
func Login() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var input LoginInput
                if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.LoginResponse{Status: http.StatusBadRequest, Message: "error"})
                        return
                }</span>

                <span class="cov0" title="0">user, err := models.FindUser(input.Username)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.LoginResponse{Status: http.StatusBadRequest, Message: "user not found"})
                        return
                }</span>

                <span class="cov0" title="0">token, err := user.LoginCheck(input.Password)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.LoginResponse{Status: http.StatusBadRequest, Message: "password is incorrect"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, responses.LoginResponse{Status: http.StatusOK, Message: "logged in", Token: token, Username: input.Username})</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package controllers

import (
        "net/http"
        "trainder-api/models"
        "trainder-api/responses"
        "trainder-api/utils/tokens"

        "github.com/gin-gonic/gin"
)

type BookingForm struct {
        Trainer   string `json:"trainer"`
        Date      string `json:"date"`
        StartTime string `json:"startTime"`
        EndTime   string `json:"endTime"`
}

type UpdateBookingForm struct {
        BookingId string `json:"bookingId" binding:"required"`
        Status    string `json:"status"`
}

type DeleteBookingForm struct {
        BookingId string `json:"bookingId" binding:"required"`
}

// type specificDateEventForm struct {
//         Date string `json:"date"`
// }

// @Summary Create a new booking
// @Description Creates a new booking with the specified trainer, trainee, date, start time, and end time
// @Tags bookings
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param json_in_ginContext body BookingForm true "put booking details and pass to gin.Context"
// @Success 200 {object} string "booking created successfully"
// @Failure 400 {object} string "bad request"
// @Failure 500 {object} string "internal server error"
// @Router /protected/create-booking [post]
func Book() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var input BookingForm
                if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.CreateBookingResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">username, err := tokens.ExtractTokenUsername(c)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.CreateBookingResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">err = models.CreateBooking(username, input.Trainer, input.Date, input.StartTime, input.EndTime)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.CreateBookingResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK,
                        responses.CreateBookingResponse{
                                Status:  http.StatusOK,
                                Message: `success!`,
                        })</span>
        }
}

// @Summary Get bookings for the logged in user
// @Description Retrieve a list of upcoming bookings for the user who is currently logged in
// @Tags bookings
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} responses.GetBookingsResponse
// @Failure 400 {object} responses.GetBookingsResponse
// @Router /protected/bookings [GET]
func GetBookings() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                username, err := tokens.ExtractTokenUsername(c)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.GetBookingsResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                }</span>
                <span class="cov0" title="0">result, err := models.GetUpcomingBookings(username)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.GetBookingsResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, responses.GetBookingsResponse{
                        Status:   http.StatusOK,
                        Message:  `success!`,
                        Bookings: result,
                })</span>
        }
}

// @Summary Get booking by ID
// @Description Retrieve a single booking using id
// @Tags bookings
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} responses.GetBookingResponse
// @Failure 400 {object} responses.GetBookingResponse
// @Router /protected/booking [GET]
func GetBooking() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                username, err := tokens.ExtractTokenUsername(c)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, responses.GetBookingResponse{
                                Status:  http.StatusUnauthorized,
                                Message: err.Error(),
                        })
                }</span>
                <span class="cov0" title="0">queryParams := c.Request.URL.Query()
                bookingIDs, prs := queryParams["id"]
                if !prs </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.GetBookingResponse{
                                Status:  http.StatusBadRequest,
                                Message: "id not found in query",
                        })
                }</span>

                // Only use the first value in query
                <span class="cov0" title="0">bookingID := bookingIDs[0]
                result, err := models.GetBooking(bookingID)
                if result.Trainee != username &amp;&amp; result.Trainer != username </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, responses.GetBookingResponse{
                                Status:  http.StatusUnauthorized,
                                Message: "can only view own booking",
                        })
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.GetBookingResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, responses.GetBookingResponse{
                        Status:   http.StatusOK,
                        Message:  `success!`,
                        Bookings: result,
                })</span>
        }
}

// @Summary Update a booking
// @Description Update a booking of specified bookingId with the specified update input consist of status(pending/confirm/complete) and paymentStatus(pending/paid)
// @Tags bookings
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param json_in_ginContext body UpdateBookingForm true "put updateBookingForm details and pass to gin.Context"
// @Success        200                {object}        responses.UpdateBookingResponse        "Successfully update booking"
// @Failure        400                {object}        responses.UpdateBookingResponse        "Bad Request, missing filed of objectId or cannot find bookingObjectId"
// @Router /protected/update-booking [post]
func UpdateBooking() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var input UpdateBookingForm
                if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.UpdateBookingResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        return
                }</span>

                <span class="cov0" title="0">username, err := tokens.ExtractTokenUsername(c)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, responses.UpdateBookingResponse{
                                Status:  http.StatusUnauthorized,
                                Message: `cannot extract username from token`,
                        })
                        return
                }</span>

                <span class="cov0" title="0">if !models.IsTrainer(username) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, responses.UpdateBookingResponse{
                                Status:  http.StatusUnauthorized,
                                Message: `only Trainer can update the status`,
                        })
                        return
                }</span>

                <span class="cov0" title="0">err = models.UpdateBooking(input.BookingId, input.Status, username)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.UpdateBookingResponse{
                                Status:  http.StatusBadRequest,
                                Message: `update failed ` + err.Error(),
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK,
                        responses.UpdateBookingResponse{
                                Status:  http.StatusOK,
                                Message: `update booking success!`,
                        })</span>
        }
}

// @Summary Delete a booking
// @Description Delete a booking with the specified bookingId
// @Tags bookings
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param json_in_ginContext body DeleteBookingForm true "put DeleteBookingForm details and pass to gin.Context"
// @Success        200                {object}        responses.DeleteBookingResponse        "Successfully delete booking"
// @Failure        400                {object}        responses.DeleteBookingResponse        "Bad Request, missing filed of objectId or cannot find bookingObjectId"
// @Router /protected/delete-booking [delete]
func DeleteBooking() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var input DeleteBookingForm
                if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.DeleteBookingResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">err := models.DeleteBooking(input.BookingId)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.DeleteBookingResponse{
                                Status:  http.StatusBadRequest,
                                Message: `delete booking failed: ` + err.Error(),
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK,
                        responses.UpdateBookingResponse{
                                Status:  http.StatusOK,
                                Message: `delete booking success!`,
                        })</span>
        }
}

// @Summary Get today bookings for the logged in user
// @Description Retrieve a list of today bookings for the user who is currently logged in
// @Tags bookings
// @Accept json
// @Produce json
// @Param date query string true "put date in query param in format yyyy-mm-dd"
// @Security BearerAuth
// @Success 200 {object} responses.GetBookingsResponse
// @Failure 400 {object} responses.GetBookingsResponse
// @Router /protected/today-event [GET]
func GetTodayEvents() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                date := c.Query("date")
                username, err := tokens.ExtractTokenUsername(c)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.GetBookingsResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                }</span>
                // var input specificDateEventForm
                // if err := c.ShouldBindJSON(&amp;input); err != nil {
                //         c.JSON(http.StatusBadRequest, responses.GetBookingsResponse{
                //                 Status:  http.StatusBadRequest,
                //                 Message: err.Error(),
                //         })
                //         return
                // }

                <span class="cov0" title="0">result, err := models.GetSpecificDayBookings(username, date)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.GetBookingsResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, responses.GetBookingsResponse{
                        Status:   http.StatusOK,
                        Message:  `success!`,
                        Bookings: result,
                })</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package controllers

import (
        "fmt"
        "net/http"
        "trainder-api/models"
        "trainder-api/responses"
        "trainder-api/utils/tokens"

        "github.com/gin-gonic/gin"
)

// @Summary Get roomID to communicate with audience
// @Description Get roomID to communicate with audience (can omit this function by using the roomID format trainer_{trainerUsername}_trainee_{traineeUsername})  NOTICE THAT all time in chat is at UTC
// @Tags chats
// @Accept json
// @Produce json
// @Param audience query string true "audience of this conversation (username)"
// @Security BearerAuth
// @Success 200 {object} responses.ChatRoomIDResponse
// @Failure 400 {object} responses.ChatRoomIDResponse
// @Router /protected/get-room-id [GET]
func GetRoomID() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                audience := c.Query("audience")
                username, err := tokens.ExtractTokenUsername(c)
                var rid string
                if models.IsTrainer(username) </span><span class="cov0" title="0">{
                        rid = fmt.Sprintf("trainer_%s_trainee_%s", username, audience)
                }</span> else<span class="cov0" title="0"> {
                        rid = fmt.Sprintf("trainer_%s_trainee_%s", audience, username)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.ChatRoomIDResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, responses.ChatRoomIDResponse{
                        Status: http.StatusOK,
                        RoomID: rid,
                })</span>
        }
}

// @Summary Get all chat on sidebar that user communicate with
// @Description Get all chat on sidebar that user communicate with with their latest message NOTICE THAT all time in chat is at UTC
// @Tags chats
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} responses.AllChatResponse
// @Failure 400 {object} responses.AllChatResponse
// @Router /protected/get-all-chats [GET]
func GetChatsAndLatestMessage() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                username, err := tokens.ExtractTokenUsername(c)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.AllChatResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                }</span>
                <span class="cov0" title="0">result, err := models.GetAllChatLatestMessage(username)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, responses.AllChatResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, responses.AllChatResponse{
                        Status:  http.StatusOK,
                        Message: `success!`,
                        AllChat: result,
                })</span>
        }
}

// @Summary Get all messages that user communicate with specific audience
// @Description Get all messages that user communicate with specific audience NOTICE THAT all time in chat is at UTC
// @Tags chats
// @Accept json
// @Produce json
// @Param audience query string true "audience of this conversation (username)"
// @Security BearerAuth
// @Success 200 {object} responses.PastChatResponse
// @Failure 400 {object} responses.PastChatResponse
// @Router /protected/get-past-chat [GET]
func GetPastChat() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                audience := c.Query("audience")
                username, err := tokens.ExtractTokenUsername(c)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.PastChatResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                }</span>
                <span class="cov0" title="0">result, err := models.GetPastChat(username, audience)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, responses.PastChatResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, responses.PastChatResponse{
                        Status:       http.StatusOK,
                        Message:      `success!`,
                        ChatMessages: result,
                })</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package controllers

import (
        "encoding/base64"
        "fmt"
        "io"
        "io/ioutil"
        "log"
        "mime"
        "path/filepath"

        "go.mongodb.org/mongo-driver/bson/primitive"

        // "mime/multipart"
        "net/http"

        // "os"

        "trainder-api/models"
        "trainder-api/responses"
        "trainder-api/utils/tokens"

        "github.com/gin-gonic/gin"
)

// @Summary Upload profile picture
// @Description Upload profile picture
// @Tags image
// @Accept png
// @Produce json
// @Param image formData file true "file for uploading"
// @Security BearerAuth
// @Success 200 {object} responses.ImageResponse
// @Failure 400 {object} responses.ImageResponse
// @Router /protected/image [POST]
func UploadProfile() gin.HandlerFunc <span class="cov0" title="0">{
        fmt.Println("UploadProfile")
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                file, err := c.FormFile("image")
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.ImageResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })

                        return
                }</span>

                <span class="cov0" title="0">if file.Size &lt;= 0 </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.ImageResponse{
                                Status:  http.StatusBadRequest,
                                Message: "Uploaded file is empty: " + err.Error(),
                        })
                        // c.JSON(http.StatusBadRequest, gin.H{"error": "Uploaded file is empty"})
                        return
                }</span>

                <span class="cov0" title="0">f, err := file.Open()
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.ImageResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        // c.JSON(http.StatusInternalServerError, gin.H{"error2": err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">defer f.Close()

                fileID, err := models.Upload(file.Filename, f)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                // log.Printf("File uploaded with ID: %v\n", fileID)

                // c.JSON(http.StatusOK, gin.H{"message": "Image uploaded successfully"})

                // update profile with avatar URI = fileID
                <span class="cov0" title="0">username, err := tokens.ExtractTokenUsername(c)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.ProfileResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">_, err = models.UpdateAvatarUrl(username, fileID.Hex())
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, responses.ProfileResponse{
                                Status:  http.StatusInternalServerError,
                                Message: err.Error(),
                        })
                        // c.JSON(http.StatusInternalServerError, gin.H{"error2": err.Error()})
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, responses.ImageResponse{
                        Status:  http.StatusOK,
                        Message: "Image uploaded successfully",
                })</span>

        }
}
func getContentType(filename string) string <span class="cov0" title="0">{
        contentType := mime.TypeByExtension(filepath.Ext(filename))
        return contentType
}</span>

func isObjectID(value string) bool <span class="cov0" title="0">{
        _, err := primitive.ObjectIDFromHex(value)
        return err == nil
}</span>

// return picture not json

// @Summary retrieve  profile picture
// @Description retrieve profile picture by username return image
// @Tags image
// @Accept json
// @Produce png
// @Security BearerAuth
// @Param username query string true "username of the person you want profile picture"
// @Success 200 {object} responses.ImageResponse
// @Failure 400 {object} responses.ImageResponse
// @Failure 500 {object} responses.ImageResponse
// @Router /protected/image2 [GET]
func GetPicture2() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // id := c.Query("ID")
                username := c.Query("username")
                imageId, err := models.GetAvatarUrl(username)
                if imageId != "" &amp;&amp; (!isObjectID(imageId)) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.ImageResponse{
                                Status:  http.StatusBadRequest,
                                Message: "there is no profile picture for this user",
                        })
                        // c.JSON(http.StatusInternalServerError, gin.H{"error2": err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.ImageResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        // c.JSON(http.StatusInternalServerError, gin.H{"error2": err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">downloadStream, filename, err := models.RetrieveFileFromMongo(imageId)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                <span class="cov0" title="0">defer downloadStream.Close()

                // fmt.Println(getContentType(filename))

                // Set the response headers
                c.Header("Content-Disposition", "attachment; filename="+filename)
                c.Header("Content-Type", getContentType(filename))

                // Copy the file data to the response writer
                _, err = io.Copy(c.Writer, downloadStream)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.ImageResponse{
                                Status:  http.StatusBadRequest,
                                Message: "Error writing file to response" + err.Error(),
                        })
                        // c.JSON(http.StatusInternalServerError, gin.H{"error3": "Error writing file to response"})
                        return
                }</span>

                // log.Println("File send")

        }
}

// @Summary retrieve  profile picture
// @Description retrieve profile picture by username return json
// @Tags image
// @Accept json
// @Produce json
// @Param username query string true "username of the person you want profile picture"
// @Security BearerAuth
// @Success 200 {object} responses.ImageResponse
// @Failure 400 {object} responses.ImageResponse
// @Failure 500 {object} responses.ImageResponse
// @Router /protected/image [GET]
func GetPicture() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // id := c.Query("ID")
                username := c.Query("username")
                imageId, err := models.GetAvatarUrl(username)
                if imageId != "" &amp;&amp; (!isObjectID(imageId)) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.ImageResponse{
                                Status:  http.StatusBadRequest,
                                Message: "there is no profile picture for this user",
                        })
                        // c.JSON(http.StatusInternalServerError, gin.H{"error2": err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.ImageResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        // c.JSON(http.StatusInternalServerError, gin.H{"error2": err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">downloadStream, filename, err := models.RetrieveFileFromMongo(imageId)
                if err != nil </span><span class="cov0" title="0">{
                        // log.Fatal(err)
                        c.JSON(http.StatusInternalServerError, responses.ImageResponse{
                                Status:  http.StatusInternalServerError,
                                Message: err.Error(),
                        })
                }</span>
                <span class="cov0" title="0">defer downloadStream.Close()

                // Read the image data into a byte slice
                imgData, err := ioutil.ReadAll(downloadStream)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, responses.ImageResponse{
                                Status:  http.StatusInternalServerError,
                                Message: "Error reading image data:" + err.Error(),
                        })
                        // c.JSON(http.StatusInternalServerError, gin.H{"error3": "Error reading image data"})
                        return
                }</span>

                // Encode the image data as a base64 string
                <span class="cov0" title="0">imgBase64 := base64.StdEncoding.EncodeToString(imgData)

                // Set the response headers and send the JSON response
                c.Header("Content-Disposition", "attachment; filename="+filename)
                c.Header("Content-Type", "application/json")
                c.JSON(http.StatusOK, responses.ImageResponse{
                        Status:  http.StatusOK,
                        Message: imgBase64,
                })</span>
                // c.JSON(http.StatusOK, responses.ImageResponse{
                //         Status:  http.StatusOK,
                //         Message: "imgBase64",
                // })
                // log.Fatal("fff", imgBase64)

        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package controllers

import (
        "fmt"
        "net/http"
        "trainder-api/configs"
        "trainder-api/models"
        "trainder-api/responses"
        "trainder-api/utils/tokens"

        "github.com/gin-gonic/gin"
        "github.com/omise/omise-go"
        "github.com/omise/omise-go/operations"
)

type CreatePaymentForm struct {
        Token     string `json:"token" binding:"required"`
        BookingID string `json:"bookingID" binding:"required"` // amount is temp should handle via booking id and calculate
}

// @Summary                Create a payment
// @Description        Create a payment using token and bookingId
// @Tags                        payment
// @Accept                        json
// @Produce                json
// @Security                BearerAuth
// @Param                 input         body                         CreatePaymentForm        true        "details for creating payment"
// @Success                200                {object}                responses.CreatePaymentResponse
// @Router                        /protected/create-payment [post]
func CreatePayment() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var input CreatePaymentForm
                if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.CreatePaymentResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">username, err := tokens.ExtractTokenUsername(c)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, responses.CreatePaymentResponse{
                                Status:  http.StatusUnauthorized,
                                Message: `Cannot extract username from token`,
                        })
                        return
                }</span>

                <span class="cov0" title="0">paymentInfo, err := models.GetPaymentInfo(input.BookingID)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, responses.CreatePaymentResponse{
                                Status:  http.StatusInternalServerError,
                                Message: err.Error(),
                        })
                        return
                }</span>

                // Check if the user is really trainee
                <span class="cov0" title="0">if username != paymentInfo.TraineeUsername </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, responses.CreatePaymentResponse{
                                Status:  http.StatusUnauthorized,
                                Message: `booking can only be paid for by the trainee`,
                        })
                        return
                }</span>
                <span class="cov0" title="0">if paymentInfo.BookingStatus != "confirm" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.CreatePaymentResponse{
                                Status:  http.StatusBadRequest,
                                Message: `can only pay for booking that is confirmed`,
                        })
                        return
                }</span>

                // Check if the booking is already paid
                <span class="cov0" title="0">if paymentInfo.PaymentStatus == "paid" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.CreatePaymentResponse{
                                Status:  http.StatusBadRequest,
                                Message: `booking already paid`,
                        })
                        return
                }</span>

                // Creates a charge from the token
                <span class="cov0" title="0">charge, createCharge := &amp;omise.Charge{}, &amp;operations.CreateCharge{
                        Amount:   paymentInfo.TotalCost * 100,
                        Currency: "thb",
                        Card:     input.Token,
                }

                if err := configs.OmiseClient.Do(charge, createCharge); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest,
                                responses.CreatePaymentResponse{
                                        Status:  http.StatusBadRequest,
                                        Message: err.Error(),
                                })
                        return
                }</span>
                <span class="cov0" title="0">if charge.Status != omise.ChargeSuccessful </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK,
                                responses.CreatePaymentResponse{
                                        Status:  http.StatusOK,
                                        Message: fmt.Sprintf("charge fail with status: %s", charge.Status),
                                })
                        return

                }</span>

                <span class="cov0" title="0">err = models.Pay(input.BookingID, charge.ID)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError,
                                responses.CreatePaymentResponse{
                                        Status:  http.StatusInternalServerError,
                                        Message: err.Error(),
                                })
                        return

                }</span>

                <span class="cov0" title="0">msg := fmt.Sprintf("booking: %s charge: %s  amount: %s %d.%02d\n", input.BookingID, charge.ID, charge.Currency, charge.Amount/100, charge.Amount%100)
                c.JSON(http.StatusOK,
                        responses.CreatePaymentResponse{
                                Status:  http.StatusOK,
                                Message: msg,
                        })</span>
        }
}

type RequestPayoutForm struct {
        BookingID     string `json:"bookingID" binding:"required"`
        Bank          string `json:"bank" binding:"required"`
        AccountNumber string `json:"accountNumber" binding:"required"`
        AccountName   string `json:"accountName" binding:"required"`
}

// @Summary                Request a payout
// @Description        Mark payment as needed payout
// @Tags                        payment
// @Accept                        json
// @Produce                json
// @Security                BearerAuth
// @Param                 input         body                         RequestPayoutForm        true        "details for requesting payout"
// @Success                200                {object}                responses.RequestPayoutResponse
// @Success                400                {object}                responses.RequestPayoutResponse
// @Success                401                {object}                responses.RequestPayoutResponse
// @Success                403                {object}                responses.RequestPayoutResponse
// @Router                        /protected/request-payout [post]
func RequestPayout() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var input RequestPayoutForm
                if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.RequestPayoutResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">username, err := tokens.ExtractTokenUsername(c)

                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, responses.RequestPayoutResponse{
                                Status:  http.StatusUnauthorized,
                                Message: `Cannot extract username from token`,
                        })
                        return
                }</span>

                <span class="cov0" title="0">paymentInfo, err := models.GetPaymentInfo(input.BookingID)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, responses.RequestPayoutResponse{
                                Status:  http.StatusInternalServerError,
                                Message: err.Error(),
                        })
                        return
                }</span>

                <span class="cov0" title="0">if username != paymentInfo.TrainerUsername </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, responses.RequestPayoutResponse{
                                Status:  http.StatusForbidden,
                                Message: `only trainer can request payout`,
                        })
                        return
                }</span>
                <span class="cov0" title="0">if paymentInfo.PaymentStatus != "paid" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, responses.RequestPayoutResponse{
                                Status:  http.StatusForbidden,
                                Message: `only paid payment can be payout`,
                        })
                        return
                }</span>
                <span class="cov0" title="0">err = models.RequestPayout(input.BookingID, input.Bank, input.AccountName, input.AccountNumber)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.RequestPayoutResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK,
                        responses.RequestPayoutResponse{
                                Status:    http.StatusOK,
                                Message:   "success",
                                BookingID: input.BookingID,
                        })</span>

        }
}

type PayoutForm struct {
        BookingID string `json:"bookingID" binding:"required"` // amount is temp should handle via booking id and calculate
}

// @Summary                Payout
// @Description        Mark payment as payout
// @Tags                        payment
// @Accept                        json
// @Produce                json
// @Security                BearerAuth
// @Param                 input         body                         PayoutForm        true        "details for payout"
// @Success                200                {object}                responses.RequestPayoutResponse
// @Success                400                {object}                responses.RequestPayoutResponse
// @Success                401                {object}                responses.RequestPayoutResponse
// @Success                403                {object}                responses.RequestPayoutResponse
// @Router                        /protected/payout [post]
func Payout() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var input RequestPayoutForm
                if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.RequestPayoutResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">username, err := tokens.ExtractTokenUsername(c)

                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, responses.RequestPayoutResponse{
                                Status:  http.StatusUnauthorized,
                                Message: `Cannot extract username from token`,
                        })
                        return
                }</span>

                <span class="cov0" title="0">if !models.IsAdmin(username) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, responses.RequestPayoutResponse{
                                Status:  http.StatusForbidden,
                                Message: `only admin allowed`,
                        })
                        return
                }</span>

                <span class="cov0" title="0">paymentInfo, err := models.GetPaymentInfo(input.BookingID)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, responses.RequestPayoutResponse{
                                Status:  http.StatusInternalServerError,
                                Message: err.Error(),
                        })
                        return
                }</span>

                <span class="cov0" title="0">if paymentInfo.PaymentStatus != "need_payout" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.RequestPayoutResponse{
                                Status:  http.StatusBadRequest,
                                Message: `only need_payout payment can be paid out`,
                        })
                        return
                }</span>
                <span class="cov0" title="0">err = models.Payout(input.BookingID)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.RequestPayoutResponse{
                                Status:  http.StatusForbidden,
                                Message: err.Error(),
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK,
                        responses.RequestPayoutResponse{
                                Status:    http.StatusOK,
                                Message:   "success",
                                BookingID: input.BookingID,
                        })</span>

        }

}

// @Summary                Get Payment list
// @Description        Get Payment list for trainer
// @Tags                        payment
// @Accept                        json
// @Produce                json
// @Security                BearerAuth
// @Success                200                {object}                responses.BookingListResponse
// @Success                400                {object}                responses.BookingListResponse
// @Success                401                {object}                responses.BookingListResponse
// @Success                403                {object}                responses.BookingListResponse
// @Router                        /protected/payment-list [get]
func PaymentList() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                username, err := tokens.ExtractTokenUsername(c)

                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, responses.BookingListResponse{
                                Status:  http.StatusUnauthorized,
                                Message: `Cannot extract username from token`,
                        })
                        return
                }</span>
                <span class="cov0" title="0">if !models.IsTrainer(username) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, responses.BookingListResponse{
                                Status:  http.StatusForbidden,
                                Message: `only trainer can request payout`,
                        })
                        return
                }</span>
                <span class="cov0" title="0">payments, err := models.GetPaidBookings(username)

                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, responses.BookingListResponse{
                                Status:  http.StatusUnauthorized,
                                Message: err.Error(),
                        })
                        return

                }</span>
                <span class="cov0" title="0">fmt.Println(payments)

                c.JSON(http.StatusOK, responses.BookingListResponse{
                        Status:   http.StatusOK,
                        Message:  `success`,
                        Bookings: payments,
                })</span>

        }
}

// @Summary                Get Payment Need Payout
// @Description        Get Payment list that is needed payout
// @Tags                        payment
// @Accept                        json
// @Produce                json
// @Security                BearerAuth
// @Success                200                {object}                responses.BookingListResponse
// @Success                400                {object}                responses.BookingListResponse
// @Success                401                {object}                responses.BookingListResponse
// @Success                403                {object}                responses.BookingListResponse
// @Router                        /protected/payment-need-payouts [get]
func PaymentNeedPayouts() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                username, err := tokens.ExtractTokenUsername(c)

                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, responses.BookingListResponse{
                                Status:  http.StatusUnauthorized,
                                Message: `Cannot extract username from token`,
                        })
                        return
                }</span>
                <span class="cov0" title="0">if !models.IsAdmin(username) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, responses.BookingListResponse{
                                Status:  http.StatusForbidden,
                                Message: `only admin allowed`,
                        })
                        return
                }</span>

                <span class="cov0" title="0">payments, err := models.BookingNeedPayouts()
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, responses.BookingListResponse{
                                Status:  http.StatusUnauthorized,
                                Message: err.Error(),
                        })
                        return

                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, responses.BookingListResponse{
                        Status:   http.StatusOK,
                        Message:  `success`,
                        Bookings: payments,
                })</span>

        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package controllers

import (
        "net/http"

        "trainder-api/models"
        "trainder-api/responses"
        "trainder-api/utils/tokens"

        "strconv"

        "github.com/gin-gonic/gin"
)

type FilterTrainerForm struct {
        Specialty []string `json:"specialty"`
        Limit     int      `json:"limit" binding:"required"`
        FeeMin    int      `json:"feeMin"`
        FeeMax    int      `json:"feeMax"`
}
type UpdateTrainerDetails struct {
        Specialty      []string `json:"specialty"`
        Rating         float64  `json:"rating"`
        Fee            int      `json:"fee"`
        TraineeCount   int      `json:"traineeCount"`
        CertificateUrl string   `json:"certificateUrl"`
}
type GetTrainerForm struct {
        Username string `json:"username" binding:"required"`
}

type ReviewDetails struct {
        TrainerUsername string `json:"trainerUsername" binding:"required"`
        Comment         string `json:"comment"`
        Rating          int    `json:"rating" binding:"required"`
}

type GetReviewsForm struct {
        TrainerUsername string `json:"trainerUsername" binding:"required"`
        Limit           int    `json:"limit" binding:"required"`
}

type TraineeReviewableForm struct {
        TrainerUsername string `json:"trainerUsername" binding:"required"`
}

// CurrentTrainerUserProfile retrieves the trainer profile of the current user for the user that is a trainer
//
//        @Summary                Retrieve trainer profile of current user
//        @Description        Retrieves the trainer profile information of the current user.
//        @Tags                        Trainer
//        @Accept                        json
//        @Produce                json
//        @Success                200        {object}        responses.TrainerProfileResponse        "Successfully retrieved the trainer profile"
//        @Failure                400        {object}        responses.TrainerProfileResponse        "Failed to retrieve the trainer profile"
//        @Security                BearerAuth
//        @Router                        /protected/trainer-profile [get]
func CurrentTrainerUserProfile() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                username, err := tokens.ExtractTokenUsername(c)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.TrainerProfileResponse{
                                Status:  http.StatusBadRequest,
                                Message: "Failed to retrieve the trainer profile",
                        })
                        return
                }</span>
                <span class="cov0" title="0">userProfile, trainerProfile, err := models.FindTrainerProfile(username)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.TrainerProfileResponse{
                                Status:  http.StatusBadRequest,
                                Message: "Failed to retrieve the trainer profile",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, responses.TrainerProfileResponse{
                        Status:      http.StatusOK,
                        Message:     `Successfully retrieve trainer profile`,
                        User:        userProfile,
                        TrainerInfo: trainerProfile,
                })</span>
        }
}

// GetTrainerProfile retrieves the trainer profile of any trainer
//
//        @Summary                Retrieve trainer profile
//        @Description        Retrieves the trainer profile information.
//        @Tags                        Trainer
//        @Accept                        json
//        @Produce                json
//        @Param                        input        body                GetTrainerForm true                                        "Put username input for retrieving the trainer profile"
//        @Success                200                {object}        responses.TrainerProfileResponse        "Successfully retrieved the trainer profile"
//        @Failure                400                {object}        responses.TrainerProfileResponse        "Failed to retrieve the trainer profile"
//        @Security                BearerAuth
//        @Router                        /protected/trainer [post]
func GetTrainerProfile() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var input GetTrainerForm
                if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.TrainerProfileResponse{
                                Status:  http.StatusBadRequest,
                                Message: "input missing"})
                        return
                }</span>
                <span class="cov0" title="0">userProfile, trainerProfile, err := models.FindTrainerProfile(input.Username)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.TrainerProfileResponse{
                                Status:  http.StatusBadRequest,
                                Message: "Failed to retrieve the trainer profile",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, responses.TrainerProfileResponse{
                        Status:      http.StatusOK,
                        Message:     `Successfully retrieve trainer profile`,
                        User:        userProfile,
                        TrainerInfo: trainerProfile,
                })</span>
        }
}

// Update the trainer's profile information.
//
//        @Summary        Update the trainer's profile information.
//        @Tags                Trainer
//        @Accept                json
//        @Produce        json
//        @Param                profile        body                UpdateTrainerDetails true        "Trainer's information to update"
//        @Success        200                {object}        responses.ProfileResponse        "Successfully update the trainer's profile"
//        @Failure        400                {object}        responses.ProfileResponse        "Bad Request, either invalid input or user is not a trainer"
//        @Failure        401                {object}        responses.ProfileResponse        "Unauthorized, the user is not logged in"
//        @Security        BearerAuth
//        @Router                /protected/update-trainer [post]
func UpdateTrainerProfile() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var input UpdateTrainerDetails
                if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.ProfileResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">username, err := tokens.ExtractTokenUsername(c)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.ProfileResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">_, err = models.UpdateTrainerProfile(
                        username, input.Specialty, input.Rating,
                        input.Fee, input.TraineeCount, input.CertificateUrl)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.ProfileResponse{
                                Status:  http.StatusBadRequest,
                                Message: `update failed`,
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK,
                        responses.ProfileResponse{
                                Status:  http.StatusOK,
                                Message: username + ` update success!`,
                        })</span>
        }
}

// FilterTrainer godoc
//
//        @Summary                FilterTrainer base on filter input
//        @Description        FilterTrainer base on filter input
//        @Tags                        Trainer
//        @Accept                        json
//        @Produce                json
//        @Param                        FilterTrainer        body                FilterTrainerForm true        "Parameters for filtering trainers"
//        @Success                200                                {object}        responses.FilterTrainerResponse
//        @Failure                400                                {object}        responses.FilterTrainerResponse
//        @Security                BearerAuth
//        @Router                        /protected/filter-trainer [post]
func FilterTrainer() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var input FilterTrainerForm
                if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.FilterTrainerResponse{
                                Status:  http.StatusBadRequest,
                                Message: "input missing",
                        })
                        return
                }</span>
                <span class="cov0" title="0">result, err := models.FindFilteredTrainer(input.Specialty, input.Limit, input.FeeMin, input.FeeMax)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.FilterTrainerResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, responses.FilterTrainerResponse{
                        Status:   http.StatusOK,
                        Message:  `Successfully retrieve filtered trainer`,
                        Trainers: result,
                })</span>
        }
}

// @Summary                Get reviews of specific trainer
// @Description        Get reviews of specific trainer username from database sort by recent date then rating desc, limit number of output by limit
// @Tags                Trainer
// @Accept                json
// @Produce                json
// @Param                GetReviewsInput        body                GetReviewsForm true        "Parameters for querying trainer reviews"
// @Success                200                                {object}        responses.TrainerReviewsResponse
// @Failure                400                                {object}        responses.TrainerReviewsResponse
// @Security        BearerAuth
// @Router                /protected/reviews [post]
func GetReviews() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var input GetReviewsForm

                if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.TrainerReviewsResponse{
                                Status:  http.StatusBadRequest,
                                Message: "input missing",
                        })
                        return
                }</span>
                // fmt.Println("input", input)
                <span class="cov0" title="0">result, err := models.GetReviews(input.TrainerUsername, input.Limit)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.TrainerReviewsResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, responses.TrainerReviewsResponse{
                        Status:  http.StatusOK,
                        Message: `Successfully retrieve reviews of trainer ` + input.TrainerUsername,
                        Reviews: result,
                })</span>
        }
}

// @Summary                Add trainer review
// @Description        Add review on trainer to database
// @Tags                Trainer
// @Accept                json
// @Produce                json
// @Param                ReviewRequest        body                ReviewDetails        true        "Parameters for trainer review"
// @Success                200                                {object}        responses.AddReviewResponse
// @Failure                400                                {object}        responses.AddReviewResponse
// @Security        BearerAuth
// @Router                /protected/add-review [post]
func AddTrainerReview() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var input ReviewDetails
                if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.AddReviewResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">username, err := tokens.ExtractTokenUsername(c)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.AddReviewResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">err = models.AddReview(input.TrainerUsername, username, input.Rating, input.Comment)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.AddReviewResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK,
                        responses.RegisterResponse{
                                Status:  http.StatusOK,
                                Message: input.TrainerUsername + ` update success!`,
                        })</span>
        }
}

// @Summary                find if this trainee can still review a specific trainer
// @Description        find if this trainee can still review a specific trainer by (find number of times trainee paid that trainer) minus (number of time trainee comment on that trainer)
// @Tags                Trainer
// @Accept                json
// @Produce                json
// @Param                Reviewable        body                TraineeReviewableForm        true        "Parameters for trainee reviewable (trainer username)"
// @Success                200                                {object}        responses.ReviewableResponse
// @Failure                400                                {object}        responses.ReviewableResponse
// @Security        BearerAuth
// @Router                /protected/reviewable [POST]
func Reviewable() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var input TraineeReviewableForm
                if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.ReviewableResponse{
                                Status:    http.StatusBadRequest,
                                Message:   err.Error(),
                                CanReview: false,
                        })
                        return
                }</span>
                <span class="cov0" title="0">username, err := tokens.ExtractTokenUsername(c)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.ReviewableResponse{
                                Status:    http.StatusBadRequest,
                                Message:   err.Error(),
                                CanReview: false,
                        })
                        return
                }</span>
                <span class="cov0" title="0">canReview, reviewLeft, err := models.Reviewable(username, input.TrainerUsername)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.ReviewableResponse{
                                Status:    http.StatusBadRequest,
                                Message:   err.Error(),
                                CanReview: false,
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, responses.ReviewableResponse{
                        Status:    http.StatusOK,
                        Message:   username + ` has ` + strconv.Itoa(reviewLeft) + ` review(s) left for reviewing trainer ` + input.TrainerUsername,
                        CanReview: canReview,
                })</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package controllers

import (
        "net/http"

        "trainder-api/models"
        "trainder-api/responses"
        "trainder-api/utils/tokens"

        "github.com/gin-gonic/gin"
)

type ProfileDetails struct {
        FirstName   string `json:"firstname" binding:"required"`
        LastName    string `json:"lastname" binding:"required"`
        BirthDate   string `json:"birthdate" binding:"required"`
        CitizenId   string `json:"citizenId" binding:"required"`
        Gender      string `json:"gender" binding:"required"`
        PhoneNumber string `json:"phoneNumber" binding:"required"`
        Address     string `json:"address" binding:"required"`
        AvatarUrl   string `json:"avatarUrl"`
}

// CurrentUser godoc
//
//                @Summary                get the current user's username
//                @Description        get the current user's username.  After getting token replied from logging in, put token in ginContext's token field
//                @Tags                        user
//                @Accept                        json
//                @Produce                json
//                @Security                BearerAuth
//                @Success                200        {object}        responses.CurrentUserResponse
//         @Failure                400        {object}        responses.CurrentUserResponse
//                @Security                BearerAuth
//                @Router                        /protected/user [get]
func CurrentUser() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                username, err := tokens.ExtractTokenUsername(c)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.CurrentUserResponse{
                                Status:  http.StatusBadGateway,
                                Message: err.Error(),
                        })
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, responses.CurrentUserResponse{
                        Status:   http.StatusOK,
                        Username: username,
                })</span>
        }

}

// UpdateProfile godoc
//
//                @Summary                updateProfile of the current user
//                @Description        updateProfile of the current user
//                @Tags                        user
//                @Accept                        json
//                @Produce                json
//                @Param                        ProfileToUpdate        body                ProfileDetails        true        "put profile input json and pass to  gin.Context"
//                @Success                200                                {object}        responses.ProfileResponse
//         @Failure                400                                {object}        responses.ProfileResponse
//                @Security                BearerAuth
//                @Router                        /protected/update-profile [post]
func UpdateProfile() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var input ProfileDetails
                if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.ProfileResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">username, err := tokens.ExtractTokenUsername(c)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.ProfileResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">err = models.ProfileConditionCheck(input.FirstName, input.LastName, input.BirthDate, input.CitizenId, input.Gender, input.PhoneNumber)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.ProfileResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        return
                }</span>
                <span class="cov0" title="0">_, err = models.UpdateUserProfile(username, input.FirstName, input.LastName, input.BirthDate, input.CitizenId, input.Gender, input.PhoneNumber, input.Address, input.AvatarUrl)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.ProfileResponse{
                                Status:  http.StatusBadRequest,
                                Message: `update failed`,
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK,
                        responses.ProfileResponse{
                                Status:  http.StatusOK,
                                Message: username + ` update success!`,
                        })</span>
        }
}

// getProfile godoc
//
//        @Summary                getProfile of the current user
//        @Description        getProfile of the current user
//        @Tags                        user
//        @Accept                        json
//        @Produce                json
//        @Success                200        {object}        responses.UserProfileResponse
//        @Failure                401        {object}        responses.UserProfileResponse        "Unauthorized, the user is not logged in"
//        @Security                BearerAuth
//        @Router                        /protected/profile [get]
func GetProfile() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                username, err := tokens.ExtractTokenUsername(c)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.UserProfileResponse{
                                Status:  http.StatusBadRequest,
                                Message: err.Error(),
                        })
                        return
                }</span>

                <span class="cov0" title="0">result, err := models.FindProfile(username, "")
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.UserProfileResponse{
                                Status:  http.StatusBadRequest,
                                Message: `User profile retrieval unsuccessful`,
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, responses.UserProfileResponse{
                        Status:  http.StatusOK,
                        Message: `Successfully retrieve user profile`,
                        User:    result,
                })
                _ = result</span>
        }
}

// @Summary                Get first name, last name, and role of any user given username
// @Description        Get first name, last name, and role of any user given username
// @Tags                        Helper
// @Accept                        json
// @Produce                json
// @Param                        username query string true "username of the person you want"
// @Success                200                {object}        responses.NameAndRoleResponse
// @Failure                500        {object}        responses.NameAndRoleResponse
//
//        @Security                BearerAuth
//
// @Router                        /protected/get-name-and-role [GET]
func GetNameAndRole() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                username := c.Query("username")

                result, err := models.GetNameAndRole(username)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, responses.NameAndRoleResponse{
                                Status:  http.StatusInternalServerError,
                                Message: err.Error(),
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, responses.NameAndRoleResponse{
                        Status:  http.StatusOK,
                        Message: `Successfully GetNameAndRole`,
                        Result:  result,
                })</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/login": {
            "post": {
                "description": "login with username and password",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "authentication"
                ],
                "summary": "Login",
                "parameters": [
                    {
                        "description": "put login input and pass to  gin.Context",
                        "name": "json_in_ginContext",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.LoginInput"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.LoginResponse"
                        }
                    }
                }
            }
        },
        "/protected/add-review": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Add review on trainer to database",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Trainer"
                ],
                "summary": "Add trainer review",
                "parameters": [
                    {
                        "description": "Parameters for trainer review",
                        "name": "ReviewRequest",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.ReviewDetails"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.AddReviewResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/responses.AddReviewResponse"
                        }
                    }
                }
            }
        },
        "/protected/booking": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Retrieve a single booking using id",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "bookings"
                ],
                "summary": "Get booking by ID",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.GetBookingResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/responses.GetBookingResponse"
                        }
                    }
                }
            }
        },
        "/protected/bookings": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Retrieve a list of upcoming bookings for the user who is currently logged in",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "bookings"
                ],
                "summary": "Get bookings for the logged in user",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.GetBookingsResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/responses.GetBookingsResponse"
                        }
                    }
                }
            }
        },
        "/protected/create-booking": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Creates a new booking with the specified trainer, trainee, date, start time, and end time",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "bookings"
                ],
                "summary": "Create a new booking",
                "parameters": [
                    {
                        "description": "put booking details and pass to gin.Context",
                        "name": "json_in_ginContext",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.BookingForm"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "booking created successfully",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "400": {
                        "description": "bad request",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "internal server error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/protected/create-payment": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Create a payment using token and bookingId",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "payment"
                ],
                "summary": "Create a payment",
                "parameters": [
                    {
                        "description": "details for creating payment",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.CreatePaymentForm"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.CreatePaymentResponse"
                        }
                    }
                }
            }
        },
        "/protected/delete-booking": {
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Delete a booking with the specified bookingId",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "bookings"
                ],
                "summary": "Delete a booking",
                "parameters": [
                    {
                        "description": "put DeleteBookingForm details and pass to gin.Context",
                        "name": "json_in_ginContext",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.DeleteBookingForm"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successfully delete booking",
                        "schema": {
                            "$ref": "#/definitions/responses.DeleteBookingResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request, missing filed of objectId or cannot find bookingObjectId",
                        "schema": {
                            "$ref": "#/definitions/responses.DeleteBookingResponse"
                        }
                    }
                }
            }
        },
        "/protected/filter-trainer": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "FilterTrainer base on filter input",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Trainer"
                ],
                "summary": "FilterTrainer base on filter input",
                "parameters": [
                    {
                        "description": "Parameters for filtering trainers",
                        "name": "FilterTrainer",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.FilterTrainerForm"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.FilterTrainerResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/responses.FilterTrainerResponse"
                        }
                    }
                }
            }
        },
        "/protected/get-all-chats": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Get all chat on sidebar that user communicate with with their latest message NOTICE THAT all time in chat is at UTC",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "chats"
                ],
                "summary": "Get all chat on sidebar that user communicate with",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.AllChatResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/responses.AllChatResponse"
                        }
                    }
                }
            }
        },
        "/protected/get-name-and-role": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Get first name, last name, and role of any user given username",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Helper"
                ],
                "summary": "Get first name, last name, and role of any user given username",
                "parameters": [
                    {
                        "type": "string",
                        "description": "username of the person you want",
                        "name": "username",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.NameAndRoleResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/responses.NameAndRoleResponse"
                        }
                    }
                }
            }
        },
        "/protected/get-past-chat": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Get all messages that user communicate with specific audience NOTICE THAT all time in chat is at UTC",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "chats"
                ],
                "summary": "Get all messages that user communicate with specific audience",
                "parameters": [
                    {
                        "type": "string",
                        "description": "audience of this conversation (username)",
                        "name": "audience",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.PastChatResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/responses.PastChatResponse"
                        }
                    }
                }
            }
        },
        "/protected/get-room-id": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Get roomID to communicate with audience (can omit this function by using the roomID format trainer_{trainerUsername}_trainee_{traineeUsername})  NOTICE THAT all time in chat is at UTC",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "chats"
                ],
                "summary": "Get roomID to communicate with audience",
                "parameters": [
                    {
                        "type": "string",
                        "description": "audience of this conversation (username)",
                        "name": "audience",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.ChatRoomIDResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/responses.ChatRoomIDResponse"
                        }
                    }
                }
            }
        },
        "/protected/image": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "retrieve profile picture by username return json",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "image"
                ],
                "summary": "retrieve  profile picture",
                "parameters": [
                    {
                        "type": "string",
                        "description": "username of the person you want profile picture",
                        "name": "username",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.ImageResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/responses.ImageResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/responses.ImageResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Upload profile picture",
                "consumes": [
                    "image/png"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "image"
                ],
                "summary": "Upload profile picture",
                "parameters": [
                    {
                        "type": "file",
                        "description": "file for uploading",
                        "name": "image",
                        "in": "formData",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.ImageResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/responses.ImageResponse"
                        }
                    }
                }
            }
        },
        "/protected/image2": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "retrieve profile picture by username return image",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "image/png"
                ],
                "tags": [
                    "image"
                ],
                "summary": "retrieve  profile picture",
                "parameters": [
                    {
                        "type": "string",
                        "description": "username of the person you want profile picture",
                        "name": "username",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.ImageResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/responses.ImageResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/responses.ImageResponse"
                        }
                    }
                }
            }
        },
        "/protected/payment-list": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Get Payment list for trainer",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "payment"
                ],
                "summary": "Get Payment list",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.BookingListResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/responses.BookingListResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/responses.BookingListResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/responses.BookingListResponse"
                        }
                    }
                }
            }
        },
        "/protected/payment-need-payouts": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Get Payment list that is needed payout",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "payment"
                ],
                "summary": "Get Payment Need Payout",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.BookingListResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/responses.BookingListResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/responses.BookingListResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/responses.BookingListResponse"
                        }
                    }
                }
            }
        },
        "/protected/payout": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Mark payment as payout",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "payment"
                ],
                "summary": "Payout",
                "parameters": [
                    {
                        "description": "details for payout",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.PayoutForm"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.RequestPayoutResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/responses.RequestPayoutResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/responses.RequestPayoutResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/responses.RequestPayoutResponse"
                        }
                    }
                }
            }
        },
        "/protected/profile": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "getProfile of the current user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "user"
                ],
                "summary": "getProfile of the current user",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.UserProfileResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized, the user is not logged in",
                        "schema": {
                            "$ref": "#/definitions/responses.UserProfileResponse"
                        }
                    }
                }
            }
        },
        "/protected/request-payout": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Mark payment as needed payout",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "payment"
                ],
                "summary": "Request a payout",
                "parameters": [
                    {
                        "description": "details for requesting payout",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.RequestPayoutForm"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.RequestPayoutResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/responses.RequestPayoutResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/responses.RequestPayoutResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/responses.RequestPayoutResponse"
                        }
                    }
                }
            }
        },
        "/protected/reviewable": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "find if this trainee can still review a specific trainer by (find number of times trainee paid that trainer) minus (number of time trainee comment on that trainer)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Trainer"
                ],
                "summary": "find if this trainee can still review a specific trainer",
                "parameters": [
                    {
                        "description": "Parameters for trainee reviewable (trainer username)",
                        "name": "Reviewable",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.TraineeReviewableForm"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.ReviewableResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/responses.ReviewableResponse"
                        }
                    }
                }
            }
        },
        "/protected/reviews": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Get reviews of specific trainer username from database sort by recent date then rating desc, limit number of output by limit",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Trainer"
                ],
                "summary": "Get reviews of specific trainer",
                "parameters": [
                    {
                        "description": "Parameters for querying trainer reviews",
                        "name": "GetReviewsInput",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.GetReviewsForm"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.TrainerReviewsResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/responses.TrainerReviewsResponse"
                        }
                    }
                }
            }
        },
        "/protected/today-event": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Retrieve a list of today bookings for the user who is currently logged in",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "bookings"
                ],
                "summary": "Get today bookings for the logged in user",
                "parameters": [
                    {
                        "type": "string",
                        "description": "put date in query param in format yyyy-mm-dd",
                        "name": "date",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.GetBookingsResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/responses.GetBookingsResponse"
                        }
                    }
                }
            }
        },
        "/protected/trainer": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Retrieves the trainer profile information.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Trainer"
                ],
                "summary": "Retrieve trainer profile",
                "parameters": [
                    {
                        "description": "Put username input for retrieving the trainer profile",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.GetTrainerForm"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successfully retrieved the trainer profile",
                        "schema": {
                            "$ref": "#/definitions/responses.TrainerProfileResponse"
                        }
                    },
                    "400": {
                        "description": "Failed to retrieve the trainer profile",
                        "schema": {
                            "$ref": "#/definitions/responses.TrainerProfileResponse"
                        }
                    }
                }
            }
        },
        "/protected/trainer-profile": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Retrieves the trainer profile information of the current user.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Trainer"
                ],
                "summary": "Retrieve trainer profile of current user",
                "responses": {
                    "200": {
                        "description": "Successfully retrieved the trainer profile",
                        "schema": {
                            "$ref": "#/definitions/responses.TrainerProfileResponse"
                        }
                    },
                    "400": {
                        "description": "Failed to retrieve the trainer profile",
                        "schema": {
                            "$ref": "#/definitions/responses.TrainerProfileResponse"
                        }
                    }
                }
            }
        },
        "/protected/update-booking": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Update a booking of specified bookingId with the specified update input consist of status(pending/confirm/complete) and paymentStatus(pending/paid)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "bookings"
                ],
                "summary": "Update a booking",
                "parameters": [
                    {
                        "description": "put updateBookingForm details and pass to gin.Context",
                        "name": "json_in_ginContext",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.UpdateBookingForm"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successfully update booking",
                        "schema": {
                            "$ref": "#/definitions/responses.UpdateBookingResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request, missing filed of objectId or cannot find bookingObjectId",
                        "schema": {
                            "$ref": "#/definitions/responses.UpdateBookingResponse"
                        }
                    }
                }
            }
        },
        "/protected/update-profile": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "updateProfile of the current user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "user"
                ],
                "summary": "updateProfile of the current user",
                "parameters": [
                    {
                        "description": "put profile input json and pass to  gin.Context",
                        "name": "ProfileToUpdate",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.ProfileDetails"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.ProfileResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/responses.ProfileResponse"
                        }
                    }
                }
            }
        },
        "/protected/update-trainer": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Trainer"
                ],
                "summary": "Update the trainer's profile information.",
                "parameters": [
                    {
                        "description": "Trainer's information to update",
                        "name": "profile",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.UpdateTrainerDetails"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successfully update the trainer's profile",
                        "schema": {
                            "$ref": "#/definitions/responses.ProfileResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request, either invalid input or user is not a trainer",
                        "schema": {
                            "$ref": "#/definitions/responses.ProfileResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized, the user is not logged in",
                        "schema": {
                            "$ref": "#/definitions/responses.ProfileResponse"
                        }
                    }
                }
            }
        },
        "/protected/user": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    },
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "get the current user's username.  After getting token replied from logging in, put token in ginContext's token field",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "user"
                ],
                "summary": "get the current user's username",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.CurrentUserResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/responses.CurrentUserResponse"
                        }
                    }
                }
            }
        },
        "/register": {
            "post": {
                "description": "Register with username,password,UserType [\"trainer\",\"trainee\"],Firstname,Lastname,Birthdate (\"yyyy-mm-dd\"),CitizenId (len == 13),Gender [\"Male\",\"Female\",\"Other\"],PhoneNumber (len ==10),Address,SubAddress",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "authentication"
                ],
                "summary": "Register user",
                "operationId": "register-user",
                "parameters": [
                    {
                        "description": "put register input and pass to gin.Context",
                        "name": "json_in_ginContext",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controllers.RegisterInput"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/responses.RegisterResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "controllers.BookingForm": {
            "type": "object",
            "properties": {
                "date": {
                    "type": "string"
                },
                "endTime": {
                    "type": "string"
                },
                "startTime": {
                    "type": "string"
                },
                "trainer": {
                    "type": "string"
                }
            }
        },
        "controllers.CreatePaymentForm": {
            "type": "object",
            "required": [
                "bookingID",
                "token"
            ],
            "properties": {
                "bookingID": {
                    "description": "amount is temp should handle via booking id and calculate",
                    "type": "string"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "controllers.DeleteBookingForm": {
            "type": "object",
            "required": [
                "bookingId"
            ],
            "properties": {
                "bookingId": {
                    "type": "string"
                }
            }
        },
        "controllers.FilterTrainerForm": {
            "type": "object",
            "required": [
                "limit"
            ],
            "properties": {
                "feeMax": {
                    "type": "integer"
                },
                "feeMin": {
                    "type": "integer"
                },
                "limit": {
                    "type": "integer"
                },
                "specialty": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "controllers.GetReviewsForm": {
            "type": "object",
            "required": [
                "limit",
                "trainerUsername"
            ],
            "properties": {
                "limit": {
                    "type": "integer"
                },
                "trainerUsername": {
                    "type": "string"
                }
            }
        },
        "controllers.GetTrainerForm": {
            "type": "object",
            "required": [
                "username"
            ],
            "properties": {
                "username": {
                    "type": "string"
                }
            }
        },
        "controllers.LoginInput": {
            "type": "object",
            "required": [
                "password",
                "username"
            ],
            "properties": {
                "password": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "controllers.PayoutForm": {
            "type": "object",
            "required": [
                "bookingID"
            ],
            "properties": {
                "bookingID": {
                    "description": "amount is temp should handle via booking id and calculate",
                    "type": "string"
                }
            }
        },
        "controllers.ProfileDetails": {
            "type": "object",
            "required": [
                "address",
                "birthdate",
                "citizenId",
                "firstname",
                "gender",
                "lastname",
                "phoneNumber"
            ],
            "properties": {
                "address": {
                    "type": "string"
                },
                "avatarUrl": {
                    "type": "string"
                },
                "birthdate": {
                    "type": "string"
                },
                "citizenId": {
                    "type": "string"
                },
                "firstname": {
                    "type": "string"
                },
                "gender": {
                    "type": "string"
                },
                "lastname": {
                    "type": "string"
                },
                "phoneNumber": {
                    "type": "string"
                }
            }
        },
        "controllers.RegisterInput": {
            "type": "object",
            "required": [
                "address",
                "birthdate",
                "citizenId",
                "firstname",
                "gender",
                "lastname",
                "lat",
                "lng",
                "password",
                "phoneNumber",
                "username",
                "usertype"
            ],
            "properties": {
                "address": {
                    "type": "string"
                },
                "avatarUrl": {
                    "type": "string"
                },
                "birthdate": {
                    "type": "string"
                },
                "citizenId": {
                    "type": "string"
                },
                "firstname": {
                    "type": "string"
                },
                "gender": {
                    "type": "string"
                },
                "lastname": {
                    "type": "string"
                },
                "lat": {
                    "type": "number"
                },
                "lng": {
                    "type": "number"
                },
                "password": {
                    "type": "string"
                },
                "phoneNumber": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                },
                "usertype": {
                    "type": "string"
                }
            }
        },
        "controllers.RequestPayoutForm": {
            "type": "object",
            "required": [
                "bookingID"
            ],
            "properties": {
                "bookingID": {
                    "description": "amount is temp should handle via booking id and calculate",
                    "type": "string"
                }
            }
        },
        "controllers.ReviewDetails": {
            "type": "object",
            "required": [
                "rating",
                "trainerUsername"
            ],
            "properties": {
                "comment": {
                    "type": "string"
                },
                "rating": {
                    "type": "integer"
                },
                "trainerUsername": {
                    "type": "string"
                }
            }
        },
        "controllers.TraineeReviewableForm": {
            "type": "object",
            "required": [
                "trainerUsername"
            ],
            "properties": {
                "trainerUsername": {
                    "type": "string"
                }
            }
        },
        "controllers.UpdateBookingForm": {
            "type": "object",
            "required": [
                "bookingId"
            ],
            "properties": {
                "bookingId": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                }
            }
        },
        "controllers.UpdateTrainerDetails": {
            "type": "object",
            "properties": {
                "certificateUrl": {
                    "type": "string"
                },
                "fee": {
                    "type": "integer"
                },
                "rating": {
                    "type": "number"
                },
                "specialty": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "traineeCount": {
                    "type": "integer"
                }
            }
        },
        "models.AllChat": {
            "type": "object",
            "properties": {
                "audience": {
                    "type": "string"
                },
                "message": {
                    "$ref": "#/definitions/models.Message"
                }
            }
        },
        "models.Booking": {
            "type": "object",
            "properties": {
                "_id": {
                    "type": "string"
                },
                "endDateTime": {
                    "type": "string"
                },
                "payment": {
                    "$ref": "#/definitions/models.Payment"
                },
                "startDateTime": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "trainee": {
                    "type": "string"
                },
                "trainer": {
                    "type": "string"
                }
            }
        },
        "models.FilteredTrainerInfo": {
            "type": "object",
            "properties": {
                "address": {
                    "type": "string"
                },
                "avatarUrl": {
                    "type": "string"
                },
                "firstname": {
                    "type": "string"
                },
                "gender": {
                    "type": "string"
                },
                "lastname": {
                    "type": "string"
                },
                "trainerInfo": {
                    "$ref": "#/definitions/models.TrainerInfo"
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "models.Message": {
            "type": "object",
            "properties": {
                "content": {
                    "type": "string"
                },
                "createdAt": {
                    "type": "string"
                },
                "sender": {
                    "type": "string"
                }
            }
        },
        "models.NameAndRole": {
            "type": "object",
            "properties": {
                "firstname": {
                    "type": "string"
                },
                "lastname": {
                    "type": "string"
                },
                "usertype": {
                    "type": "string"
                }
            }
        },
        "models.Payment": {
            "type": "object",
            "properties": {
                "chargeID": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "totalCost": {
                    "type": "integer"
                }
            }
        },
        "models.ReturnBooking": {
            "type": "object",
            "properties": {
                "_id": {
                    "type": "string"
                },
                "endDateTime": {
                    "type": "string"
                },
                "payment": {
                    "$ref": "#/definitions/models.Payment"
                },
                "startDateTime": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "trainee": {
                    "type": "string"
                },
                "traineeFirstName": {
                    "type": "string"
                },
                "traineeLastName": {
                    "type": "string"
                },
                "trainer": {
                    "type": "string"
                },
                "trainerFirstName": {
                    "type": "string"
                },
                "trainerLastName": {
                    "type": "string"
                }
            }
        },
        "models.Review": {
            "type": "object",
            "properties": {
                "comment": {
                    "type": "string"
                },
                "createdAt": {
                    "type": "string"
                },
                "rating": {
                    "type": "integer"
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "models.TrainerInfo": {
            "type": "object",
            "properties": {
                "certificateUrl": {
                    "type": "string"
                },
                "fee": {
                    "type": "integer"
                },
                "rating": {
                    "type": "number"
                },
                "specialty": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "traineeCount": {
                    "type": "integer"
                }
            }
        },
        "models.UserProfile": {
            "type": "object",
            "properties": {
                "address": {
                    "type": "string"
                },
                "avatarUrl": {
                    "type": "string"
                },
                "birthdate": {
                    "type": "string"
                },
                "citizenId": {
                    "type": "string"
                },
                "firstname": {
                    "type": "string"
                },
                "gender": {
                    "type": "string"
                },
                "lastname": {
                    "type": "string"
                },
                "lat": {
                    "type": "number"
                },
                "lng": {
                    "type": "number"
                },
                "phoneNumber": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                },
                "usertype": {
                    "type": "string"
                }
            }
        },
        "responses.AddReviewResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                },
                "status": {
                    "type": "integer"
                }
            }
        },
        "responses.AllChatResponse": {
            "type": "object",
            "properties": {
                "allChat": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.AllChat"
                    }
                },
                "message": {
                    "type": "string"
                },
                "status": {
                    "type": "integer"
                }
            }
        },
        "responses.BookingListResponse": {
            "type": "object",
            "properties": {
                "bookings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Booking"
                    }
                },
                "message": {
                    "type": "string"
                },
                "status": {
                    "type": "integer"
                }
            }
        },
        "responses.ChatRoomIDResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                },
                "roomID": {
                    "type": "string"
                },
                "status": {
                    "type": "integer"
                }
            }
        },
        "responses.CreatePaymentResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                },
                "status": {
                    "type": "integer"
                }
            }
        },
        "responses.CurrentUserResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                },
                "status": {
                    "type": "integer"
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "responses.DeleteBookingResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                },
                "status": {
                    "type": "integer"
                }
            }
        },
        "responses.FilterTrainerResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                },
                "status": {
                    "type": "integer"
                },
                "trainers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.FilteredTrainerInfo"
                    }
                }
            }
        },
        "responses.GetBookingResponse": {
            "type": "object",
            "properties": {
                "booking": {
                    "$ref": "#/definitions/models.Booking"
                },
                "message": {
                    "type": "string"
                },
                "status": {
                    "type": "integer"
                }
            }
        },
        "responses.GetBookingsResponse": {
            "type": "object",
            "properties": {
                "bookings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.ReturnBooking"
                    }
                },
                "message": {
                    "type": "string"
                },
                "status": {
                    "type": "integer"
                }
            }
        },
        "responses.ImageResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                },
                "status": {
                    "type": "integer"
                }
            }
        },
        "responses.LoginResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                },
                "status": {
                    "type": "integer"
                },
                "token": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "responses.NameAndRoleResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                },
                "result": {
                    "$ref": "#/definitions/models.NameAndRole"
                },
                "status": {
                    "type": "integer"
                }
            }
        },
        "responses.PastChatResponse": {
            "type": "object",
            "properties": {
                "chatMessages": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Message"
                    }
                },
                "message": {
                    "type": "string"
                },
                "status": {
                    "type": "integer"
                }
            }
        },
        "responses.ProfileResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                },
                "status": {
                    "type": "integer"
                }
            }
        },
        "responses.RegisterResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                },
                "status": {
                    "type": "integer"
                }
            }
        },
        "responses.RequestPayoutResponse": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string"
                },
                "message": {
                    "type": "string"
                },
                "status": {
                    "type": "integer"
                }
            }
        },
        "responses.ReviewableResponse": {
            "type": "object",
            "properties": {
                "canReview": {
                    "type": "boolean"
                },
                "message": {
                    "type": "string"
                },
                "status": {
                    "type": "integer"
                }
            }
        },
        "responses.TrainerProfileResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                },
                "status": {
                    "type": "integer"
                },
                "trainerInfo": {
                    "$ref": "#/definitions/models.TrainerInfo"
                },
                "user": {
                    "$ref": "#/definitions/models.UserProfile"
                }
            }
        },
        "responses.TrainerReviewsResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                },
                "reviews": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Review"
                    }
                },
                "status": {
                    "type": "integer"
                }
            }
        },
        "responses.UpdateBookingResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                },
                "status": {
                    "type": "integer"
                }
            }
        },
        "responses.UserProfileResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                },
                "status": {
                    "type": "integer"
                },
                "user": {
                    "$ref": "#/definitions/models.UserProfile"
                }
            }
        }
    },
    "securityDefinitions": {
        "BearerAuth": {
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "0.1",
        Host:             "",
        BasePath:         "",
        Schemes:          []string{},
        Title:            "Trainder API",
        Description:      "API for Trainder",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
}

func init() <span class="cov8" title="1">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package main

import (
        "net/http"
        "runtime"
        "trainder-api/routes"
        "trainder-api/utils/inits"
        "trainder-api/ws"

        _ "trainder-api/docs"

        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
)

// @title                                                Trainder API
// @version                                        0.1
// @description                                API for Trainder
// @securityDefinitions.apikey        BearerAuth
// @in                                                        header
// @name                                                Authorization
func main() <span class="cov0" title="0">{
        inits.InitializeDatabase()
        router := gin.Default()
        config := cors.DefaultConfig()
        config.AllowAllOrigins = true
        config.AddAllowHeaders("Origin", "Authorization")
        router.Use(cors.New(config))
        hub := ws.NewHub()
        wsHandler := ws.NewHandler(hub)
        go hub.Run()

        router.GET("/", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "data": "Welcome to Trainder API",
                })
        }</span>)

        <span class="cov0" title="0">routes.AuthRoute(router)
        routes.ProtectedRoute(router, wsHandler)

        router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
        os := runtime.GOOS
        if os == "windows" </span><span class="cov0" title="0">{
                router.Run("127.0.0.1:8080")
        }</span> else<span class="cov0" title="0"> {
                router.Run(":8080")
        }</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package middlewares

import (
        "net/http"
        "trainder-api/utils/tokens"

        "github.com/gin-gonic/gin"
)

func JwtAuthMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                err := tokens.TokenValid(c)
                if err != nil </span><span class="cov0" title="0">{
                        c.String(http.StatusUnauthorized, "Unauthorized")
                        c.Abort()
                        return
                }</span>
                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package models

import (
        "context"
        "time"
        "trainder-api/configs"
        "trainder-api/utils/tokens"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"

        "golang.org/x/crypto/bcrypt"
)

var userCollection *mongo.Collection = configs.GetCollection(configs.DB, "users")

type TrainerInfo struct {
        Specialty      []string `bson:"specialty" json:"specialty"`
        CertificateURL string   `bson:"certificateUrl" json:"certificateUrl"`
        TraineeCount   int32    `bson:"traineeCount" json:"traineeCount"`
        Fee            int32    `bson:"fee" json:"fee"`
        Rating         float64  `bson:"rating" json:"rating"`
}
type User struct {
        Username       string      `bson:"username"`
        HashedPassword string      `bson:"hashedPassword"`
        UserType       string      `bson:"usertype"`
        FirstName      string      `bson:"firstname"`
        LastName       string      `bson:"lastname"`
        BirthDate      time.Time   `bson:"birthdate"`
        CitizenId      string      `bson:"citizenId"`
        Gender         string      `bson:"gender"`
        PhoneNumber    string      `bson:"phoneNumber"`
        Address        string      `bson:"address"`
        CreatedAt      time.Time   `bson:"createdAt"`
        UpdatedAt      time.Time   `bson:"updatedAt"`
        AvatarUrl      string      `bson:"avatarUrl"`
        Lat            float64     `bson:"lat"`
        Lng            float64     `bson:"lng"`
        TrainerInfo    TrainerInfo `bson:"trainerInfo,omitempty"`
        Reviews        []Review    `bson:"reviews"`
}

func (tr TrainerInfo) Init() TrainerInfo <span class="cov0" title="0">{
        tr.Fee = 0
        tr.Rating = 0
        tr.TraineeCount = 0
        tr.CertificateURL = "certificateURLString"
        tr.Specialty = []string{}
        return tr
}</span>

func FindUser(username string) (user User, err error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        filter := bson.D{{Key: "username", Value: username}}
        err = userCollection.FindOne(ctx, filter).Decode(&amp;user)
        return user, err
}</span>

type PasswordConditionCheckFailed struct {
        s string
}

func (e *PasswordConditionCheckFailed) Error() string <span class="cov0" title="0">{
        return e.s
}</span>

func passwordConditionCheck(password string) error <span class="cov0" title="0">{
        if len(password) &lt; 8 </span><span class="cov0" title="0">{
                return &amp;PasswordConditionCheckFailed{"Password should be more than 8 characters"}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UserAlreadyExist struct{}

func (e *UserAlreadyExist) Error() string <span class="cov0" title="0">{
        return "error: user already existed"
}</span>

func CreateUser(username string, password string, userType string, firstName string, lastName string, birthDate string, citizenID string, gender string, phoneNumber string, address string, avatarUrl string, lat float64, lng float64) (user User, err error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        user, err = FindUser(username)
        if err == nil </span><span class="cov0" title="0">{
                err = &amp;UserAlreadyExist{}
                return user, err
        }</span>
        <span class="cov0" title="0">err = passwordConditionCheck(password)
        if err != nil </span><span class="cov0" title="0">{
                return user, err
        }</span>

        <span class="cov0" title="0">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return user, err
        }</span>
        <span class="cov0" title="0">layout := "2006-01-02"
        date, error := time.Parse(layout, birthDate)

        if error != nil </span><span class="cov0" title="0">{
                return user, err
        }</span>
        <span class="cov0" title="0">var initTrainer TrainerInfo
        if userType == "Trainer" </span><span class="cov0" title="0">{
                initTrainer = new(TrainerInfo).Init()
                user = User{
                        Username:       username,
                        HashedPassword: string(hashedPassword),
                        UserType:       userType,
                        FirstName:      firstName,
                        LastName:       lastName,
                        BirthDate:      date,
                        CitizenId:      citizenID,
                        Gender:         gender,
                        PhoneNumber:    phoneNumber,
                        Address:        address,
                        CreatedAt:      time.Now(),
                        UpdatedAt:      time.Now(),
                        AvatarUrl:      avatarUrl,
                        Lat:            lat,
                        Lng:            lng,
                        TrainerInfo:    initTrainer,
                        Reviews:        []Review{},
                }

        }</span> else<span class="cov0" title="0"> {
                user = User{
                        Username:       username,
                        HashedPassword: string(hashedPassword),
                        UserType:       userType,
                        FirstName:      firstName,
                        LastName:       lastName,
                        BirthDate:      date,
                        CitizenId:      citizenID,
                        Gender:         gender,
                        PhoneNumber:    phoneNumber,
                        Address:        address,
                        CreatedAt:      time.Now(),
                        UpdatedAt:      time.Now(),
                        Lat:            lat,
                        Lng:            lng,
                        AvatarUrl:      avatarUrl,
                        Reviews:        []Review{},
                }
        }</span>

        <span class="cov0" title="0">_, err = userCollection.InsertOne(ctx, user)
        return user, err</span>
}

func (user *User) VerifyPassword(password string) error <span class="cov0" title="0">{
        return bcrypt.CompareHashAndPassword([]byte(user.HashedPassword), []byte(password))
}</span>

func (user *User) LoginCheck(password string) (token string, err error) <span class="cov0" title="0">{
        err = user.VerifyPassword(password)
        if err != nil &amp;&amp; err == bcrypt.ErrMismatchedHashAndPassword </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">token, err = tokens.GenerateToken(user.Username)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return token, err</span>
}

func DeleteUser(username string) (err error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        filter := bson.D{{Key: "username", Value: username}}
        _, err = userCollection.DeleteOne(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package models

import (
        "context"
        "fmt"
        "time"
        "trainder-api/configs"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

var bookingsCollection *mongo.Collection = configs.GetCollection(configs.DB, "bookings")

type Payment struct {
        TotalCost     int64  `bson:"totalCost" json:"totalCost"`
        Status        string `bson:"status" json:"status"`
        ChargeID      string `bson:"chargeID" json:"chargeID"`
        Bank          string `bson:"bank" json:"bank"`
        AccountName   string `bson:"accountName" json:"accountName"`
        AccountNumber string `bson:"accountNumber" json:"accountNumber"`
}

type Booking struct {
        ID            primitive.ObjectID `bson:"_id" json:"_id"`
        Trainer       string             `bson:"trainer" json:"trainer"`
        Trainee       string             `bson:"trainee" json:"trainee"`
        StartDateTime time.Time          `bson:"startDateTime" json:"startDateTime"`
        EndDateTime   time.Time          `bson:"endDateTime" json:"endDateTime"`
        Status        string             `bson:"status" json:"status"`
        Payment       Payment            `bson:"payment" json:"payment"`
}

type ReturnBooking struct {
        ID               primitive.ObjectID `bson:"_id" json:"_id"`
        Trainer          string             `bson:"trainer" json:"trainer"`
        TrainerFirstName string             `bson:"trainerFirstName" json:"trainerFirstName"`
        TrainerLastName  string             `bson:"trainerLastName" json:"trainerLastName"`
        Trainee          string             `bson:"trainee" json:"trainee"`
        TraineeFirstName string             `bson:"traineeFirstName" json:"traineeFirstName"`
        TraineeLastName  string             `bson:"traineeLastName" json:"traineeLastName"`
        StartDateTime    time.Time          `bson:"startDateTime" json:"startDateTime"`
        EndDateTime      time.Time          `bson:"endDateTime" json:"endDateTime"`
        Status           string             `bson:"status" json:"status"`
        Payment          Payment            `bson:"payment" json:"payment"`
}

func CreateBooking(trainee string, trainer string, date string, startTime string, endTime string) error <span class="cov0" title="0">{
        // fmt.Println(trainer)
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        filter := bson.M{"username": trainer, "usertype": "Trainer"}
        projection := bson.M{"trainerInfo.fee": 1, "_id": 0}
        var result struct {
                TrainerInfo struct {
                        Fee int64 `bson:"fee"`
                } `bson:"trainerInfo"`
        }
        if err := userCollection.FindOne(context.Background(), filter, options.FindOne().SetProjection(projection)).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get trainer info: %w", err)
        }</span>

        <span class="cov0" title="0">startDateTimeStr := date + " " + startTime
        startDateTime, err := time.Parse("2006-01-02 15:04", startDateTimeStr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse start datetime: %v", err)
        }</span>
        <span class="cov0" title="0">endDateTimeStr := date + " " + endTime
        endDateTime, err := time.Parse("2006-01-02 15:04", endDateTimeStr)
        if err != nil </span><span class="cov0" title="0">{

                return fmt.Errorf("failed to parse end datetime: %v", err)
        }</span>
        <span class="cov0" title="0">duration := endDateTime.Sub(startDateTime)
        totalCost := result.TrainerInfo.Fee * int64(duration.Hours())

        // Create booking object
        booking := bson.M{
                "trainer":       trainer,
                "trainee":       trainee,
                "startDateTime": startDateTime,
                "endDateTime":   endDateTime,
                "status":        "pending",
                "payment": bson.M{
                        "totalCost": totalCost,
                        "status":    "pending",
                        "chargeID":  "",
                },
        }

        // Insert booking into database
        _, err = bookingsCollection.InsertOne(ctx, booking)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create booking: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func GetBooking(bookingID string) (result Booking, err error) <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(bookingID)
        if err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>

        <span class="cov0" title="0">filter := bson.M{"_id": objectID}

        err = bookingsCollection.FindOne(context.TODO(), filter).Decode(&amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>

        <span class="cov0" title="0">return result, err</span>
}

// merge into one function ()
func GetUpcomingBookings(Username string) ([]ReturnBooking, error) <span class="cov0" title="0">{
        now := time.Now().Local()
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        var filter bson.M
        if IsTrainer(Username) </span><span class="cov0" title="0">{
                filter = bson.M{
                        "trainer": Username,
                        "startDateTime": bson.M{
                                "$gte": now.UTC().Truncate(24 * time.Hour),
                        },
                }
        }</span> else<span class="cov0" title="0"> {
                filter = bson.M{
                        "trainee": Username,
                        "startDateTime": bson.M{
                                "$gte": now.UTC().Truncate(24 * time.Hour),
                        },
                }
        }</span>

        <span class="cov0" title="0">cursor, err := bookingsCollection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var bookings []ReturnBooking
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var booking Booking
                err := cursor.Decode(&amp;booking)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">var trainerInfo User
                err = userCollection.FindOne(ctx, bson.M{"username": booking.Trainer}).Decode(&amp;trainerInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">var traineeInfo User
                err = userCollection.FindOne(ctx, bson.M{"username": booking.Trainee}).Decode(&amp;traineeInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">result := ReturnBooking{
                        ID:               booking.ID,
                        Trainer:          booking.Trainer,
                        TrainerFirstName: trainerInfo.FirstName,
                        TrainerLastName:  trainerInfo.LastName,
                        Trainee:          booking.Trainee,
                        TraineeFirstName: traineeInfo.FirstName,
                        TraineeLastName:  traineeInfo.LastName,
                        StartDateTime:    booking.StartDateTime,
                        EndDateTime:      booking.EndDateTime,
                        Status:           booking.Status,
                        Payment:          booking.Payment,
                }

                bookings = append(bookings, result)</span>
        }

        <span class="cov0" title="0">return bookings, nil</span>

}

func UpdateBooking(bookingObjectId string, status string, username string) error <span class="cov0" title="0">{
        booking, err := GetBooking(bookingObjectId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if username != booking.Trainer </span><span class="cov0" title="0">{
                return fmt.Errorf("can only update own booking")
        }</span>

        <span class="cov0" title="0">objectID, err := primitive.ObjectIDFromHex(bookingObjectId)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse bookingObjId: %v", err)
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        updateArr := bson.M{}

        if len(status) != 0 </span><span class="cov0" title="0">{
                updateArr["status"] = status
        }</span>

        <span class="cov0" title="0">res, err := bookingsCollection.UpdateOne(
                ctx,
                bson.M{"_id": objectID},
                bson.M{"$set": updateArr},
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to UpdateOne bookingsCollection: %v", err)
        }</span>
        <span class="cov0" title="0">if res.MatchedCount == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("the bookingObjectId could not be found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func DeleteBooking(bookingObjectId string) error <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(bookingObjectId)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse bookingObjId: %v", err)
        }</span>
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        res, err := bookingsCollection.DeleteOne(ctx, bson.M{"_id": objectID})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete document on bookingsCollection: %v", err)
        }</span>
        <span class="cov0" title="0">if res.DeletedCount == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("the bookingObjectId could not be found")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func GetSpecificDayBookings(Username string, date string) ([]ReturnBooking, error) <span class="cov0" title="0">{
        startDateTimeStr := date + " " + "00:00"
        datetime, err := time.Parse("2006-01-02 15:04", startDateTimeStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse start datetime: %v", err)
        }</span>
        <span class="cov0" title="0">today := datetime.Truncate(24 * time.Hour)
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        var filter bson.M
        if IsTrainer(Username) </span><span class="cov0" title="0">{
                filter = bson.M{
                        "trainer": Username,
                        "$expr": bson.M{
                                "$eq": bson.A{
                                        bson.M{"$dateToString": bson.M{"format": "%Y-%m-%d", "date": "$startDateTime"}},
                                        today.Format("2006-01-02"),
                                },
                        },
                }
        }</span> else<span class="cov0" title="0"> {
                filter = bson.M{
                        "trainee": Username,
                        "$expr": bson.M{
                                "$eq": bson.A{
                                        bson.M{"$dateToString": bson.M{"format": "%Y-%m-%d", "date": "$startDateTime"}},
                                        today.Format("2006-01-02"),
                                },
                        },
                }
        }</span>
        <span class="cov0" title="0">cursor, err := bookingsCollection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var bookings []ReturnBooking
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var booking Booking
                err := cursor.Decode(&amp;booking)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">var trainerInfo User
                err = userCollection.FindOne(ctx, bson.M{"username": booking.Trainer}).Decode(&amp;trainerInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">var traineeInfo User
                err = userCollection.FindOne(ctx, bson.M{"username": booking.Trainee}).Decode(&amp;traineeInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">result := ReturnBooking{
                        ID:               booking.ID,
                        Trainer:          booking.Trainer,
                        TrainerFirstName: trainerInfo.FirstName,
                        TrainerLastName:  trainerInfo.LastName,
                        Trainee:          booking.Trainee,
                        TraineeFirstName: traineeInfo.FirstName,
                        TraineeLastName:  traineeInfo.LastName,
                        StartDateTime:    booking.StartDateTime,
                        EndDateTime:      booking.EndDateTime,
                        Status:           booking.Status,
                        Payment:          booking.Payment,
                }
                bookings = append(bookings, result)</span>
        }

        <span class="cov0" title="0">return bookings, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package models

import (
        "context"
        "fmt"
        "strings"
        "time"
        "trainder-api/configs"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
)

var chatCollection *mongo.Collection = configs.GetCollection(configs.DB, "chats")

type Message struct {
        CreatedAt time.Time `bson:"createdAt" json:"createdAt"`
        Content   string    `bson:"content" json:"content"`
        Sender    string    `bson:"sender" json:"sender"`
}

type Chat struct {
        RoomID   string    `bson:"roomID" json:"roomID"`
        Trainer  string    `bson:"trainer" json:"trainer"`
        Trainee  string    `bson:"trainee" json:"trainee"`
        Messages []Message `bson:"messages" json:"messages"`
}

type AllChat struct {
        Audience string  `bson:"audience" json:"audience"`
        Message  Message `bson:"message" json:"message"`
}

// func FindChat(trainer string,trainee string) (chat Chat, err error) {
//         ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
//         defer cancel()
//         filter := bson.M{
//                 "trainer": trainer,
//                 "trainee": trainee,
//         }
//         err = userCollection.FindOne(ctx, filter).Decode(&amp;chat)
//         return chat, err
// }

func chatExists(trainer string, trainee string) (bool, error) <span class="cov0" title="0">{
        filter := bson.M{
                "trainer": trainer,
                "trainee": trainee,
        }
        count, err := chatCollection.CountDocuments(context.Background(), filter, nil)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

func InitChat(trainer string, trainee string) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        rid := fmt.Sprintf("trainer_%s_trainee_%s", trainer, trainee)
        chat := bson.M{
                "roomID":   rid,
                "trainer":  trainer,
                "trainee":  trainee,
                "messages": []Message{},
        }
        _, err := chatCollection.InsertOne(ctx, chat)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to init chat: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>

}

func AddMessage(roomID string, content string, sender string) error <span class="cov0" title="0">{

        s := strings.Split(roomID, "_")
        if len(s) != 4 </span><span class="cov0" title="0">{
                return fmt.Errorf("your roomID might be in wrong format")
        }</span>
        <span class="cov0" title="0">trainer := s[1]
        trainee := s[3]

        chatExists, err := chatExists(trainer, trainee)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed at chatExists: %v", err)
        }</span>
        <span class="cov0" title="0">if !chatExists </span><span class="cov0" title="0">{
                err = InitChat(trainer, trainee)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed at AddMessage: %v", err)
                }</span>
        }

        <span class="cov0" title="0">message := Message{
                CreatedAt: time.Now(),
                Content:   content,
                Sender:    sender,
        }
        filter := bson.M{
                "roomID": roomID,
        }
        update := bson.M{"$push": bson.M{"messages": message}}
        _, err = chatCollection.UpdateOne(context.Background(), filter, update)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>

}

func GetAllChatLatestMessage(username string) ([]AllChat, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        var filter bson.M
        // trainerFlag := false

        // if IsTrainer(username) {
        //         trainerFlag = true
        //         filter = bson.M{
        //                 "trainer": username,
        //         }
        // } else {
        //         filter = bson.M{
        //                 "trainee": username,
        //         }
        // }
        // if IsTrainer(username) {
        //         trainerFlag = true
        // }
        filter = bson.M{
                "$or": []bson.M{
                        {
                                "trainer": username,
                        },
                        {
                                "trainee": username,
                        },
                },
        }

        cursor, err := chatCollection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var allChats []AllChat
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var chat Chat
                err := cursor.Decode(&amp;chat)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">audience := chat.Trainer
                personB := chat.Trainee
                if username != personB </span><span class="cov0" title="0">{
                        audience = personB
                }</span>
                <span class="cov0" title="0">message := chat.Messages[len(chat.Messages)-1]
                var result AllChat
                result = AllChat{
                        Audience: audience,
                        Message:  message,
                }
                // if trainerFlag {
                //         result = AllChat{
                //                 Audience: chat.Trainee,
                //                 Message:  message,
                //         }
                // } else {
                //         result = AllChat{
                //                 Audience: chat.Trainer,
                //                 Message:  message,
                //         }
                // }

                allChats = append(allChats, result)</span>
        }

        <span class="cov0" title="0">return allChats, nil</span>
}

func GetPastChat(username string, audience string) ([]Message, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        var filter bson.M

        var messages []Message
        filter = bson.M{
                "$or": []bson.M{
                        {
                                "trainer": username,
                                "trainee": audience,
                        },
                        {
                                "trainer": audience,
                                "trainee": username,
                        },
                },
        }
        // if IsTrainer(username) {
        //         filter = bson.M{
        //                 "trainer": username,
        //                 "trainee": audience,
        //         }
        // } else {
        //         filter = bson.M{
        //                 "trainer": audience,
        //                 "trainee": username,
        //         }
        // }
        cursor, err := chatCollection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var chat Chat
                err := cursor.Decode(&amp;chat)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">messages = chat.Messages</span>
        }
        <span class="cov0" title="0">return messages, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package models

import (
        "fmt"
        "io"
        "mime/multipart"

        // "os"
        "trainder-api/configs"

        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo/gridfs"
)

// func UploadFileToMongo(file multipart.File, handler *multipart.FileHeader) (primitive.ObjectID, error) {

//         // Create a new GridFS upload stream
//         uploadStream, err := configs.Bucket.OpenUploadStream(
//                 handler.Filename,
//         )
//         if err != nil {
//                 return primitive.NilObjectID, err
//         }
//         defer uploadStream.Close()

//         // Copy the file data into the GridFS upload stream
//         _, err = io.Copy(uploadStream, file)
//         if err != nil {
//                 return primitive.NilObjectID, err
//         }

//         // Get the ID of the uploaded file
//         fileID := uploadStream.FileID.(primitive.ObjectID)

//         return fileID, nil
// }

func RetrieveFileFromMongo(fileID_str string) (*gridfs.DownloadStream, string, error) <span class="cov0" title="0">{
        fileID, err := primitive.ObjectIDFromHex(fileID_str)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("RetrieveFileFromMongo: value store at AvatarUrl is not valid ObjectId: %v", err)
        }</span>

        // Open a GridFS download stream for the file
        <span class="cov0" title="0">downloadStream, err := configs.Bucket.OpenDownloadStream(fileID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov0" title="0">filename := downloadStream.GetFile().Name

        return downloadStream, filename, nil</span>
}

// func createHeader(filename string) (*multipart.FileHeader, error) {
//         handler := &amp;multipart.FileHeader{
//                 Filename: filename,
//                 Size:     1000,
//         }

//         return handler, nil

// }

// func Upload(filename string, file multipart.File) (primitive.ObjectID, error) {
//         // file, err := openFile(filename)
//         // if err != nil {
//         //         return primitive.NilObjectID, err
//         // }
//         // handler, err := createHeader(filename)
//         // if err != nil {
//         //         return primitive.NilObjectID, err
//         // }

//         // Create a new GridFS upload stream
//         uploadStream, err := configs.Bucket.OpenUploadStream(
//                 filename,
//         )
//         if err != nil {
//                 return primitive.NilObjectID, err
//         }
//         defer uploadStream.Close()

//         // Copy the file data into the GridFS upload stream
//         _, err = io.Copy(uploadStream, file)
//         if err != nil {
//                 return primitive.NilObjectID, err
//         }

//         // Get the ID of the uploaded file
//         fileID := uploadStream.FileID.(primitive.ObjectID)

//         return fileID, nil

// }

func Upload(filename string, file multipart.File) (primitive.ObjectID, error) <span class="cov0" title="0">{

        uploadStream, err := configs.Bucket.OpenUploadStream(
                filename,
        )
        if err != nil </span><span class="cov0" title="0">{
                return primitive.NilObjectID, err
        }</span>
        <span class="cov0" title="0">defer uploadStream.Close()

        // Copy the file data into the GridFS upload stream
        _, err = io.Copy(uploadStream, file)
        if err != nil </span><span class="cov0" title="0">{
                return primitive.NilObjectID, err
        }</span>

        // Get the ID of the uploaded file
        <span class="cov0" title="0">fileID := uploadStream.FileID.(primitive.ObjectID)

        return fileID, nil</span>

}
</pre>
		
		<pre class="file" id="file16" style="display: none">package models

import (
        "context"
        "fmt"
        "time"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
)

type PaymentInfo struct {
        TraineeUsername string
        TrainerUsername string
        TotalCost       int64
        BookingStatus   string
        PaymentStatus   string
}

func GetPaymentInfo(bookingID string) (PaymentInfo, error) <span class="cov0" title="0">{
        booking, err := GetBooking(bookingID)

        return PaymentInfo{
                TraineeUsername: booking.Trainee,
                TrainerUsername: booking.Trainer,
                TotalCost:       int64(booking.Payment.TotalCost),
                BookingStatus:   booking.Status,
                PaymentStatus:   booking.Payment.Status,
        }, err
}</span>

func Pay(bookingID string, chargeId string) (err error) <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(bookingID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">filter := bson.M{"_id": objectID}

        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        updateStatus, err := bookingsCollection.UpdateOne(ctx, filter, bson.M{"$set": bson.M{"payment.status": "paid", "payment.chargeID": chargeId}})

        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return fmt.Errorf("no booking matched the requested id")
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">if updateStatus.MatchedCount == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("the bookingObjectId could not be found")
        }</span>

        <span class="cov0" title="0">return err</span>

}

func RequestPayout(bookingID string, bank string, accountName string, accountNumber string) (err error) <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(bookingID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">filter := bson.M{"_id": objectID}

        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        updateStatus, err := bookingsCollection.UpdateOne(ctx, filter, bson.M{
                "$set": bson.M{
                        "payment.status":        "need_payout",
                        "payment.bank":          bank,
                        "payment.accountName":   accountName,
                        "payment.accountNumber": accountNumber,
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return fmt.Errorf("no booking matched the requested id")
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">if updateStatus.MatchedCount == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("the bookingObjectId could not be found")
        }</span>

        <span class="cov0" title="0">return err</span>
}

func Payout(bookingID string) (err error) <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(bookingID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">filter := bson.M{"_id": objectID}

        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        updateStatus, err := bookingsCollection.UpdateOne(ctx, filter, bson.M{"$set": bson.M{"payment.status": "paid_out"}})

        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return fmt.Errorf("no booking matched the requested id")
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">if updateStatus.MatchedCount == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("the bookingObjectId could not be found")
        }</span>

        <span class="cov0" title="0">return err</span>
}

func BookingNeedPayouts() (bookings []Booking, err error) <span class="cov0" title="0">{
        filter := bson.M{"payment.status": "need_payout"}
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        cursor, err := bookingsCollection.Find(ctx, filter)

        if err != nil </span><span class="cov0" title="0">{
                return bookings, err
        }</span>
        <span class="cov0" title="0">if err = cursor.All(context.TODO(), &amp;bookings); err != nil </span><span class="cov0" title="0">{
                return bookings, err
        }</span>

        <span class="cov0" title="0">return bookings, err</span>

}

func GetPaidBookings(username string) (bookings []Booking, err error) <span class="cov0" title="0">{
        filter := bson.M{"trainer": username, "payment.status": "paid"}
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        cursor, err := bookingsCollection.Find(ctx, filter)

        if err != nil </span><span class="cov0" title="0">{
                return bookings, err
        }</span>
        <span class="cov0" title="0">if err = cursor.All(context.TODO(), &amp;bookings); err != nil </span><span class="cov0" title="0">{
                return bookings, err
        }</span>

        <span class="cov0" title="0">return bookings, err</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package models

import (
        "context"
        "fmt"
        "math"
        "time"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type FilteredTrainerInfo struct {
        Username    string      `json:"username"`
        FirstName   string      `json:"firstname"`
        LastName    string      `json:"lastname"`
        Gender      string      `json:"gender"`
        Address     string      `json:"address"`
        AvatarUrl   string      `json:"avatarUrl"`
        TrainerInfo TrainerInfo `json:"trainerInfo"`
}
type Review struct {
        Username  string    `bson:"username"`
        Comment   string    `bson:"comment"`
        Rating    int       `bson:"rating"`
        CreatedAt time.Time `bson:"createdAt"`
}
type UserNotExist struct{}

func (e *UserNotExist) Error() string <span class="cov0" title="0">{
        return "error: user not existed"
}</span>

// Use for only finding the profile of a trainer, which will have normal user profile and trainer info
func FindTrainerProfile(username string) (userProfile UserProfile, trainerInfo TrainerInfo, err error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        filter := bson.D{{Key: "username", Value: username}, {Key: "usertype", Value: "Trainer"}}
        opts := options.FindOne().SetProjection(bson.D{
                {Key: "_id", Value: 0},
                {Key: "hashedPassword", Value: 0},
                {Key: "createdAt", Value: 0},
                {Key: "updatedAt", Value: 0}})
        var user User
        err = userCollection.FindOne(ctx, filter, opts).Decode(&amp;user)
        if err != nil </span><span class="cov0" title="0">{
                return userProfile, trainerInfo, err
        }</span>
        <span class="cov0" title="0">userProfile = UserProfile{
                Username:    user.Username,
                UserType:    user.UserType,
                FirstName:   user.FirstName,
                LastName:    user.LastName,
                BirthDate:   user.BirthDate.Format("2006-01-02"),
                Gender:      user.Gender,
                PhoneNumber: user.PhoneNumber,
                Address:     user.Address,
                AvatarUrl:   user.AvatarUrl,
                Lat:         user.Lat,
                Lng:         user.Lng,
        }
        return userProfile, user.TrainerInfo, nil</span>
}

func userExists(username string) (bool, error) <span class="cov0" title="0">{
        filter := bson.M{"username": username}
        count, err := userCollection.CountDocuments(context.Background(), filter, nil)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

func updateRatingByUsername(username string) error <span class="cov0" title="0">{
        projection := bson.M{"reviews": 1, "_id": 0}
        var user User
        err := userCollection.FindOne(context.Background(), bson.M{"username": username}, options.FindOne().SetProjection(projection)).Decode(&amp;user)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">var sum int
        for _, review := range user.Reviews </span><span class="cov0" title="0">{
                sum += review.Rating
        }</span>
        <span class="cov0" title="0">avgRating := math.Round(float64(sum)/float64(len(user.Reviews))*100) / 100
        _, err = userCollection.UpdateOne(context.Background(), bson.M{"username": username}, bson.M{"$set": bson.M{"trainerInfo.rating": avgRating}})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func AddReview(trainerUsername string, username string, rating int, comment string) error <span class="cov0" title="0">{
        isExist, err := userExists(trainerUsername)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !isExist </span><span class="cov0" title="0">{
                err = &amp;UserNotExist{}
                return err
        }</span>
        <span class="cov0" title="0">review := Review{
                Username:  username,
                Rating:    rating,
                Comment:   comment,
                CreatedAt: time.Now(),
        }
        filter := bson.M{"username": trainerUsername}
        update := bson.M{"$push": bson.M{"reviews": review}}
        _, err = userCollection.UpdateOne(context.Background(), filter, update)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = updateRatingByUsername(trainerUsername)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>

}

func FindFilteredTrainer(specialty []string, limit int, feeLowerBound int, feeUpperBound int) ([]FilteredTrainerInfo, error) <span class="cov10" title="5">{
        ctx := context.TODO()

        var results []FilteredTrainerInfo
        var opts *options.FindOptions
        var filterArr []bson.D

        if len(specialty) == 0 </span><span class="cov4" title="2">{
                filterArr = append(filterArr, bson.D{{Key: "usertype", Value: "Trainer"}})

        }</span> else<span class="cov7" title="3"> {
                filterArr = append(filterArr, bson.D{{Key: "trainerInfo.specialty", Value: bson.D{{Key: "$in", Value: specialty}}}})
                filterArr = append(filterArr, bson.D{{Key: "usertype", Value: "Trainer"}})
        }</span>

        // filter by fee
        <span class="cov10" title="5">if feeLowerBound == 0 &amp;&amp; feeUpperBound == 0 </span><span class="cov8" title="4">{
                feeUpperBound = 1000000000
        }</span>
        <span class="cov10" title="5">filter2 := bson.D{
                {
                        Key: "trainerInfo.fee",
                        Value: bson.M{
                                "$gte": feeLowerBound,
                                "$lte": feeUpperBound,
                        },
                },
        }

        filterArr = append(filterArr, filter2)

        filter := bson.M{
                "$and": filterArr,
        }

        opts = options.Find().SetLimit(int64(limit)).SetSort(bson.D{
                {Key: "trainerInfo.rating", Value: -1},
                {Key: "fee", Value: 1},
        }).SetProjection(bson.D{
                {Key: "_id", Value: 0},
                {Key: "hashedPassword", Value: 0},
                {Key: "createdAt", Value: 0},
                {Key: "updatedAt", Value: 0},
                {Key: "birthDate", Value: 0},
                {Key: "citizenId", Value: 0},
                {Key: "phoneNumber", Value: 0},
                {Key: "userType", Value: 0}})
        cur, err := userCollection.Find(ctx, filter, opts)

        if err != nil </span>{<span class="cov0" title="0">
                // return nil, err
        }</span>

        <span class="cov10" title="5">defer cur.Close(ctx)
        for cur.Next(ctx) </span><span class="cov8" title="4">{
                var user User
                if err := cur.Decode(&amp;user); err != nil </span>{<span class="cov0" title="0">
                        // return nil, err
                }</span>
                <span class="cov8" title="4">result := FilteredTrainerInfo{
                        FirstName:   user.FirstName,
                        LastName:    user.LastName,
                        Gender:      user.Gender,
                        Address:     user.Address,
                        AvatarUrl:   user.AvatarUrl,
                        Username:    user.Username,
                        TrainerInfo: user.TrainerInfo,
                }
                results = append(results, result)</span>
        }
        // if err := cur.Err(); err != nil {
        //         return nil, err
        // }

        <span class="cov10" title="5">return results, nil</span>
}

func UpdateTrainerProfile(username string, specialty []string, rating float64, fee int, traineeCount int, certificateUrl string) (result *mongo.UpdateResult, err error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        update := bson.M{
                "$set": bson.M{
                        "trainerInfo.specialty":      specialty,
                        "updatedAt":                  time.Now(),
                        "trainerInfo.rating":         rating,
                        "trainerInfo.fee":            fee,
                        "trainerInfo.traineeCount":   traineeCount,
                        "trainerInfo.certificateUrl": certificateUrl,
                },
        }
        result, err = userCollection.UpdateOne(
                ctx,
                bson.M{"username": username},
                update,
        )
        return
}</span>

func IsTrainer(username string) (b bool) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        filter := bson.D{{Key: "username", Value: username}}
        var user User
        err := userCollection.FindOne(ctx, filter).Decode(&amp;user)
        if err != nil || user.UserType != "Trainer" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}
func IsAdmin(username string) (b bool) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        filter := bson.D{{Key: "username", Value: username}}
        var user User
        err := userCollection.FindOne(ctx, filter).Decode(&amp;user)
        if err != nil || user.UserType != "Admin" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func GetDistance(lat1 float64, lng1 float64, lat2 float64, lng2 float64) float64 <span class="cov0" title="0">{
        const PI float64 = math.Pi
        radlat1 := float64(PI * lat1 / 180)
        radlat2 := float64(PI * lat2 / 180)
        theta := float64(lng1 - lng2)
        radtheta := float64(PI * theta / 180)
        dist := math.Sin(radlat1)*math.Sin(radlat2) + math.Cos(radlat1)*math.Cos(radlat2)*math.Cos(radtheta)
        if dist &gt; 1 </span><span class="cov0" title="0">{
                dist = 1
        }</span>
        <span class="cov0" title="0">dist = math.Acos(dist)

        return dist * 180 / PI * 1.609344 * 60 * 1.1515</span>
}

func GetReviews(username string, limit int) ([]Review, error) <span class="cov0" title="0">{
        isExist, err := userExists(username)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !isExist </span><span class="cov0" title="0">{
                err = &amp;UserNotExist{}
                return nil, err
        }</span>
        <span class="cov0" title="0">_, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        pipeline := bson.A{
                bson.M{"$match": bson.M{"username": username}},
                bson.M{"$unwind": "$reviews"},
                bson.M{"$sort": bson.M{"reviews.createdAt": -1, "reviews.rating": -1}},
                bson.M{"$limit": limit},
                bson.M{"$group": bson.M{
                        "_id":      "$_id",
                        "username": bson.M{"$first": "$username"},
                        "reviews":  bson.M{"$push": "$reviews"},
                }},
                bson.M{"$project": bson.M{
                        "_id":      0,
                        "username": 1,
                        "reviews":  1,
                }},
        }
        limitOptions := options.Aggregate().SetMaxTime(2 * time.Second)

        var result struct {
                ReviewSlice []Review `bson:"reviews"`
        }
        cursor, err := userCollection.Aggregate(context.Background(), pipeline, limitOptions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(context.Background())
        reviews := make([]Review, 0)
        // Iterate through the results
        for cursor.Next(context.Background()) </span><span class="cov0" title="0">{
                err := cursor.Decode(&amp;result)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">for _, r := range result.ReviewSlice </span><span class="cov0" title="0">{
                        review := Review{
                                Username:  r.Username,
                                Rating:    r.Rating,
                                Comment:   r.Comment,
                                CreatedAt: r.CreatedAt,
                        }
                        reviews = append(reviews, review)
                }</span>

        }

        <span class="cov0" title="0">return reviews, nil</span>

}

func Reviewable(traineeUsername string, trainerUsername string) (bool, int, error) <span class="cov0" title="0">{
        trainingCount, err := getPaidTrainingCount(traineeUsername, trainerUsername)
        if err != nil </span><span class="cov0" title="0">{
                return false, 0, fmt.Errorf("Error from Reviewable: failed to getPaidTrainingCount: %v", err)
        }</span>
        <span class="cov0" title="0">commentCount, err := getCommentCountFromTrainee(traineeUsername, trainerUsername)
        if err != nil </span><span class="cov0" title="0">{
                return false, 0, fmt.Errorf("Error from Reviewable: failed to getCommentCountFromTrainee: %v", err)
        }</span>
        <span class="cov0" title="0">commentLeft := trainingCount - commentCount
        if commentLeft &gt; 0 </span><span class="cov0" title="0">{
                return true, commentLeft, nil
        }</span> else<span class="cov0" title="0"> {
                return false, commentLeft, nil
        }</span>

}
func getPaidTrainingCount(traineeUsername string, trainerUsername string) (int, error) <span class="cov0" title="0">{
        fmt.Println(trainerUsername, traineeUsername)
        _, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        filter := bson.M{
                "trainer":        trainerUsername,
                "trainee":        traineeUsername,
                "payment.status": "paid",
        }
        count, err := bookingsCollection.CountDocuments(context.Background(), filter)
        fmt.Println(count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return int(count), nil</span>

}

func getCommentCountFromTrainee(traineeUsername string, trainerUsername string) (int, error) <span class="cov0" title="0">{

        isExist, err := userExists(trainerUsername)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">if !isExist </span><span class="cov0" title="0">{
                err = &amp;UserNotExist{}
                return 0, err
        }</span>
        <span class="cov0" title="0">filter := bson.M{"username": trainerUsername}
        var result User

        err = userCollection.FindOne(context.Background(), filter).Decode(&amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">if len(result.Reviews) == 0 </span><span class="cov0" title="0">{
                fmt.Println("Reviews field is empty")
                return 0, nil
        }</span>

        <span class="cov0" title="0">_, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        pipeline := bson.A{
                bson.M{"$match": bson.M{"username": trainerUsername}},
                bson.M{"$unwind": "$reviews"},
                bson.M{"$match": bson.M{"reviews.username": traineeUsername}},
                bson.M{"$group": bson.M{
                        "_id":   "$_id",
                        "count": bson.M{"$sum": 1},
                }},
                bson.M{"$project": bson.M{
                        "_id":   0,
                        "count": 1,
                }},
        }
        limitOptions := options.Aggregate().SetMaxTime(2 * time.Second)

        cursor, err := userCollection.Aggregate(context.Background(), pipeline, limitOptions)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("Error from getCommentCountFromTrainee: %v", err)
        }</span>
        <span class="cov0" title="0">defer cursor.Close(context.Background())
        if cursor.Next(context.Background()) </span><span class="cov0" title="0">{
                var result struct {
                        Count int `bson:"count"`
                }
                err = cursor.Decode(&amp;result)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">return result.Count, nil</span>
        }
        <span class="cov0" title="0">return 0, fmt.Errorf("Error from getCommentCountFromTrainee: %v", err)</span>

}
</pre>
		
		<pre class="file" id="file18" style="display: none">package models

import (
        "context"
        "errors"
        "fmt"
        "regexp"
        "strconv"
        "time"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type UserProfile struct {
        Username    string  `json:"username"`
        UserType    string  `json:"usertype"`
        FirstName   string  `json:"firstname"`
        LastName    string  `json:"lastname"`
        BirthDate   string  `json:"birthdate"`
        CitizenId   string  `json:"citizenId"`
        Gender      string  `json:"gender"`
        PhoneNumber string  `json:"phoneNumber"`
        Address     string  `json:"address"`
        AvatarUrl   string  `json:"avatarUrl"`
        Lat         float64 `json:"lat"`
        Lng         float64 `json:"lng"`
}

func FindProfile(username, userType string) (result UserProfile, err error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        filter := bson.D{{Key: "username", Value: username}}
        if userType != "" </span><span class="cov0" title="0">{
                filter = append(filter, bson.E{Key: "usertype", Value: userType})
        }</span>
        <span class="cov0" title="0">opts := options.FindOne().SetProjection(bson.D{
                {Key: "_id", Value: 0},
                {Key: "hashedPassword", Value: 0},
                {Key: "createdAt", Value: 0},
                {Key: "updatedAt", Value: 0}})
        var user User
        err = userCollection.FindOne(ctx, filter, opts).Decode(&amp;user)
        if err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>
        <span class="cov0" title="0">result = UserProfile{
                Username:    user.Username,
                UserType:    user.UserType,
                FirstName:   user.FirstName,
                LastName:    user.LastName,
                BirthDate:   user.BirthDate.Format("2006-01-02"),
                CitizenId:   user.CitizenId,
                Gender:      user.Gender,
                PhoneNumber: user.PhoneNumber,
                Address:     user.Address,
                AvatarUrl:   user.AvatarUrl,
        }
        return result, nil</span>
}

func UpdateUserProfile(username string, firstName string, lastName string, birthDate string, citizenID string, gender string, phoneNumber string, address string, avatarUrl string) (result *mongo.UpdateResult, err error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        // err = ProfileConditionCheck(firstName, lastName, birthDate, citizenID, gender, phoneNumber)

        layout := "2006-01-02"
        date, error := time.Parse(layout, birthDate)

        if error != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">info := bson.M{
                "firstname":   firstName,
                "lastname":    lastName,
                "birthdate":   date,
                "citizenId":   citizenID,
                "gender":      gender,
                "phoneNumber": phoneNumber,
                "address":     address,
                "updatedAt":   time.Now(),
        }
        if avatarUrl != "" </span><span class="cov0" title="0">{
                info["avatarUrl"] = avatarUrl
        }</span>

        <span class="cov0" title="0">result, err = userCollection.UpdateOne(
                ctx,
                bson.M{"username": username},
                bson.M{"$set": info},
        )
        return</span>
}

func UpdateAvatarUrl(username string, imageID string) (result *mongo.UpdateResult, err error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        filter := bson.M{"username": username}
        update := bson.M{"$set": bson.M{
                "updatedAt": time.Now(),
                "avatarUrl": imageID,
        }}
        result, err = userCollection.UpdateOne(ctx, filter, update)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func GetAvatarUrl(username string) (string, error) <span class="cov0" title="0">{
        // ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        // defer cancel()
        // filter := bson.M{"username": username}
        profile, err := FindProfile(username, "")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("Error from FindProfile in GetAvatarUrl %v", err)
        }</span>
        // fmt.Println("GetAvatarUrl", profile.AvatarUrl)

        <span class="cov0" title="0">return profile.AvatarUrl, nil</span>
}

func ProfileConditionCheck(firstName string, lastName string, birthDate string, citizenID string, gender string, phoneNumber string) error <span class="cov0" title="0">{
        //---------------check firstName not contain strange character, number  (accepting)
        if alpha := isAlphaString(firstName); !alpha </span><span class="cov0" title="0">{
                return errors.New("firstName invalid")
        }</span>

        <span class="cov0" title="0">if alpha := isAlphaString(lastName); !alpha </span><span class="cov0" title="0">{
                return errors.New("lastName invalid")
        }</span>
        //---------------check date format

        <span class="cov0" title="0">const dateFormat = `^\d{4}-\d{2}-\d{2}$`
        match, err := regexp.MatchString(dateFormat, birthDate)
        if err != nil </span><span class="cov0" title="0">{
                // fmt.Println("xxxx")
                return err
        }</span>
        <span class="cov0" title="0">if !match </span><span class="cov0" title="0">{
                return errors.New("date must be in the format 'yyyy-mm-dd'")
        }</span>
        //---------------check date value
        <span class="cov0" title="0">layout := "2006-01-02"
        date, error := time.Parse(layout, birthDate)
        if error != nil </span><span class="cov0" title="0">{
                return error
        }</span>
        <span class="cov0" title="0">now := time.Now()
        if date.After(now) </span><span class="cov0" title="0">{
                return errors.New("date is After current time")

        }</span>
        // ---------------check citizenID
        // TODO: enable id checking for production"
        // err = assertThaiID(citizenID)
        // if err != nil {
        //         return err
        // }

        // ---------------check gender
        <span class="cov0" title="0">validGenders := []string{"Male", "Female", "Other"}

        isValidGender := false
        for _, v := range validGenders </span><span class="cov0" title="0">{
                if v == gender </span><span class="cov0" title="0">{
                        isValidGender = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !isValidGender </span><span class="cov0" title="0">{
                return errors.New(" gender is not valid, valid gender in ['Male', 'Female', 'Other'] ")
        }</span>
        // check phoneNumber
        <span class="cov0" title="0">if len(phoneNumber) != 10 </span><span class="cov0" title="0">{
                return errors.New("phoneNumber is not valid, must have length 10")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func assertThaiID(thaiID string) error <span class="cov0" title="0">{
        re := regexp.MustCompile(`(\d{12})(\d)`)
        matches := re.FindStringSubmatch(thaiID)
        if len(matches) == 0 </span><span class="cov0" title="0">{
                return errors.New("bad input from user, invalid thaiID, length != 13")

        }</span>

        <span class="cov0" title="0">digits := matches[1]
        sum := 0
        for i, digit := range digits </span><span class="cov0" title="0">{
                d, _ := strconv.Atoi(string(digit))
                sum += (13 - i) * d
        }</span>
        <span class="cov0" title="0">lastDigit := (11 - sum%11) % 10
        inputLastDigit, _ := strconv.Atoi(matches[2])
        if lastDigit != inputLastDigit </span><span class="cov0" title="0">{
                return errors.New("bad input from user, invalid thaiID")

        }</span>

        <span class="cov0" title="0">return nil</span>
}

func isAlphaString(input string) bool <span class="cov0" title="0">{
        // Use a regular expression to match only alphabet characters
        match, _ := regexp.MatchString("^[a-zA-Z\u0E00-\u0E7F]+$", input)
        return match
}</span>

// use for normal registration the user cannot be "Admin"
func UserTypeCheck(userType string) error <span class="cov0" title="0">{
        validUserType := []string{"Trainer", "Trainee"}

        isValidUserType := false
        for _, v := range validUserType </span><span class="cov0" title="0">{
                if v == userType </span><span class="cov0" title="0">{
                        isValidUserType = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !isValidUserType </span><span class="cov0" title="0">{
                return errors.New(" userType is not valid, valid userType in ['Trainer', 'Trainee'] ")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type NameAndRole struct {
        FirstName string `json:"firstname"`
        LastName  string `json:"lastname"`
        UserType  string `json:"usertype"`
}

func GetNameAndRole(username string) (NameAndRole, error) <span class="cov0" title="0">{
        var result NameAndRole
        profile, err := FindProfile(username, "")
        if err != nil </span><span class="cov0" title="0">{
                return result, fmt.Errorf("Error from FindProfile in GetName %v", err)
        }</span>
        <span class="cov0" title="0">result = NameAndRole{
                FirstName: profile.FirstName,
                LastName:  profile.LastName,
                UserType:  profile.UserType,
        }
        return result, nil</span>

}
</pre>
		
		<pre class="file" id="file19" style="display: none">package routes

import (
        "trainder-api/controllers"

        "github.com/gin-gonic/gin"
)

func AuthRoute(router *gin.Engine) <span class="cov0" title="0">{
        router.POST("/register", controllers.Register())
        router.POST("/login", controllers.Login())

}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package routes

import (
        "trainder-api/controllers"
        "trainder-api/middlewares"
        "trainder-api/ws"

        "github.com/gin-gonic/gin"
)

func ProtectedRoute(router *gin.Engine, wsHandler *ws.Handler) <span class="cov0" title="0">{
        protected := router.Group("/protected")
        protected.Use(middlewares.JwtAuthMiddleware())

        // Current user information
        protected.GET("/user", controllers.CurrentUser())
        protected.GET("/profile", controllers.GetProfile())

        // Own Trainer Information
        protected.GET("/trainer-profile", controllers.CurrentTrainerUserProfile())

        // Update data
        protected.POST("/update-profile", controllers.UpdateProfile())
        protected.POST("/update-trainer", controllers.UpdateTrainerProfile())

        // Get Others Trainer information
        protected.POST("/trainer", controllers.GetTrainerProfile())
        protected.POST("/filter-trainer", controllers.FilterTrainer())

        // Get review
        protected.POST("/reviews", controllers.GetReviews())

        // Add review
        protected.POST("/add-review", controllers.AddTrainerReview())

        // Add booking
        protected.POST("/create-booking", controllers.Book())

        // Get bookings
        protected.GET("/booking", controllers.GetBooking())
        protected.GET("/bookings", controllers.GetBookings())
        protected.GET("/today-event", controllers.GetTodayEvents())

        // Booking
        protected.POST("/update-booking", controllers.UpdateBooking())
        protected.DELETE("/delete-booking", controllers.DeleteBooking())

        // Reviewable
        protected.POST("/reviewable", controllers.Reviewable())

        // chat
        protected.POST("/create-room", wsHandler.CreateRoom)
        protected.GET("/get-rooms", wsHandler.GetRooms)
        protected.GET("/get-clients/:roomId", wsHandler.GetClients)
        router.GET("/join-room/:roomId", wsHandler.JoinRoom)

        //chat and DB part
        protected.GET("/get-room-id", controllers.GetRoomID())
        protected.GET("/get-all-chats", controllers.GetChatsAndLatestMessage())
        protected.GET("/get-past-chat", controllers.GetPastChat())

        // Payment
        protected.POST("/create-payment", controllers.CreatePayment())
        protected.POST("/request-payout", controllers.RequestPayout())
        protected.POST("/payout", controllers.Payout())
        protected.GET("/payment-list", controllers.PaymentList())
        protected.GET("/payment-need-payouts", controllers.PaymentNeedPayouts())

        //helper API
        protected.GET("/get-name-and-role", controllers.GetNameAndRole())

        // image
        protected.POST("/image", controllers.UploadProfile())
        protected.GET("/image", controllers.GetPicture())
        protected.GET("/image2", controllers.GetPicture2())

}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package inits

import (
        "context"
        "fmt"
        "log"
        "time"
        "trainder-api/configs"
        "trainder-api/models"

        "go.mongodb.org/mongo-driver/bson"
)

func InitializeDatabase() <span class="cov0" title="0">{
        // Check if `users` &amp; `bookings` collection exists
        db := configs.DB.Database(configs.EnvMongoDBName())
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        collectionNames, err := db.ListCollectionNames(ctx, bson.D{{}})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">userCollectionExists := false
        for _, collectionName := range collectionNames </span><span class="cov0" title="0">{
                if collectionName == "users" </span><span class="cov0" title="0">{
                        userCollectionExists = true
                }</span> 
        }
        <span class="cov0" title="0">if !userCollectionExists </span><span class="cov0" title="0">{
                fmt.Println("User collections does not exist, creating `users` collection with `root` user")
                CreateRootUser()
        }</span>
}

type RootUserInfo struct {
        Username    string
        Password    string
        UserType    string
        Firstname   string
        Lastname    string
        Birthdate   string
        CitizenId   string
        Gender      string
        PhoneNumber string
        Address     string
        Lat         float64
        Lng         float64
        AvatarUrl   string
}

// This function will be run to populate the databases with an initial user
// The user will be `root` and that users password will be defined as env ""
func CreateRootUser() <span class="cov0" title="0">{
        rootUserInfo := RootUserInfo{
                Username:    "root",
                Password:    configs.EnvInitRootPassword(),
                UserType:    "Admin",
                Firstname:   "Admin",
                Lastname:    "Trainder",
                Birthdate:   time.Now().Format("2006-01-02"),
                CitizenId:   "0000000000000",
                Gender:      "Other",
                PhoneNumber: "0000000000",
                Address:     "-",
                Lat:         0,
                Lng:         0,
                AvatarUrl:   "",
        }

        profileErr := models.ProfileConditionCheck(rootUserInfo.Firstname, rootUserInfo.Lastname, rootUserInfo.Birthdate, rootUserInfo.CitizenId, rootUserInfo.Gender, rootUserInfo.PhoneNumber)
        if profileErr != nil </span><span class="cov0" title="0">{
                log.Fatal(profileErr.Error())
                return
        }</span>

        <span class="cov0" title="0">_, err := models.CreateUser(rootUserInfo.Username, rootUserInfo.Password, rootUserInfo.UserType, rootUserInfo.Firstname, rootUserInfo.Lastname, rootUserInfo.Birthdate, rootUserInfo.CitizenId, rootUserInfo.Gender, rootUserInfo.PhoneNumber, rootUserInfo.Address, rootUserInfo.AvatarUrl, rootUserInfo.Lat, rootUserInfo.Lng)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err.Error())
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package tokens

import (
        "fmt"
        "strings"
        "time"
        "trainder-api/configs"

        "github.com/dgrijalva/jwt-go"
        "github.com/gin-gonic/gin"
)

func GenerateToken(username string) (string, error) <span class="cov0" title="0">{
        token_lifespan, err := configs.EnvTokenLifeSpan()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">claims := jwt.MapClaims{}
        claims["authorized"] = true
        claims["username"] = username
        claims["exp"] = time.Now().Add(time.Hour * time.Duration(token_lifespan)).Unix()
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

        return token.SignedString([]byte(configs.EnvApiSecret()))</span>
}

func TokenValid(c *gin.Context) error <span class="cov0" title="0">{
        tokenString := ExtractToken(c)
        _, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return []byte(configs.EnvApiSecret()), nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func ExtractToken(c *gin.Context) string <span class="cov0" title="0">{
        token := c.Query("token")
        if token != "" </span><span class="cov0" title="0">{
                return token
        }</span>
        <span class="cov0" title="0">bearerToken := c.Request.Header.Get("Authorization")
        if len(strings.Split(bearerToken, " ")) == 2 </span><span class="cov0" title="0">{
                return strings.Split(bearerToken, " ")[1]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func ExtractTokenUsername(c *gin.Context) (string, error) <span class="cov0" title="0">{
        tokenString := ExtractToken(c)
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return []byte(configs.EnvApiSecret()), nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">claims, ok := token.Claims.(jwt.MapClaims)
        if ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                username := fmt.Sprintf("%v", claims["username"])
                return username, nil
        }</span>
        <span class="cov0" title="0">return "", nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package ws

import (
        "log"
        "trainder-api/models"

        "github.com/gorilla/websocket"
)

type Client struct {
        Conn     *websocket.Conn
        Message  chan *Message
        RoomID   string `json:"roomId"`
        Username string `json:"username"`
}

type Message struct {
        Content  string `json:"content"`
        RoomID   string `json:"roomId"`
        Username string `json:"username"`
}

func (c *Client) writeMessage() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                c.Conn.Close()
        }</span>()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                message, ok := &lt;-c.Message
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">c.Conn.WriteJSON(message)</span>
        }
}

func (c *Client) readMessage(hub *Hub) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                hub.Unregister &lt;- c
                c.Conn.Close()
        }</span>()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                _, m, err := c.Conn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                log.Printf("error: %v", err)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }

                <span class="cov0" title="0">msg := &amp;Message{
                        Content:  string(m),
                        RoomID:   c.RoomID,
                        Username: c.Username,
                }

                // fmt.Println("msg", msg.Content, msg.RoomID, msg.Username)

                hub.Broadcast &lt;- msg

                err = models.AddMessage(msg.RoomID, msg.Content, msg.Username)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("error adding message to database: %v", err)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package ws

type Room struct {
        ID      string             `json:"id"`
        Trainer string             `json:"trainer"`
        Trainee string             `json:"trainee"`
        Clients map[string]*Client `json:"clients"`
}

type Hub struct {
        Rooms      map[string]*Room
        Register   chan *Client
        Unregister chan *Client
        Broadcast  chan *Message
}

func NewHub() *Hub <span class="cov0" title="0">{
        return &amp;Hub{
                Rooms:      make(map[string]*Room),
                Register:   make(chan *Client),
                Unregister: make(chan *Client),
                Broadcast:  make(chan *Message, 5),
        }
}</span>

func (h *Hub) Run() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case cl := &lt;-h.Register:<span class="cov0" title="0">
                        if _, ok := h.Rooms[cl.RoomID]; ok </span><span class="cov0" title="0">{
                                r := h.Rooms[cl.RoomID]

                                if _, ok := r.Clients[cl.Username]; !ok </span><span class="cov0" title="0">{
                                        r.Clients[cl.Username] = cl
                                }</span>
                        }
                case cl := &lt;-h.Unregister:<span class="cov0" title="0">
                        if _, ok := h.Rooms[cl.RoomID]; ok </span><span class="cov0" title="0">{
                                if _, ok := h.Rooms[cl.RoomID].Clients[cl.Username]; ok </span><span class="cov0" title="0">{
                                        if len(h.Rooms[cl.RoomID].Clients) != 0 </span><span class="cov0" title="0">{
                                                h.Broadcast &lt;- &amp;Message{
                                                        Content:  "user left the chat",
                                                        RoomID:   cl.RoomID,
                                                        Username: cl.Username,
                                                }
                                        }</span>

                                        <span class="cov0" title="0">delete(h.Rooms[cl.RoomID].Clients, cl.Username)
                                        close(cl.Message)</span>
                                }
                        }

                case m := &lt;-h.Broadcast:<span class="cov0" title="0">
                        if _, ok := h.Rooms[m.RoomID]; ok </span><span class="cov0" title="0">{

                                for _, cl := range h.Rooms[m.RoomID].Clients </span><span class="cov0" title="0">{
                                        cl.Message &lt;- m
                                }</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package ws

import (
        "fmt"
        "net/http"
        "trainder-api/utils/tokens"

        "github.com/gin-gonic/gin"
        "github.com/gorilla/websocket"
)

type Handler struct {
        hub *Hub
}
type GetRoomsResponse struct {
        Status int       `json:"status"`
        Rooms  []RoomRes `json:"rooms"`
}

func NewHandler(h *Hub) *Handler <span class="cov0" title="0">{
        return &amp;Handler{
                hub: h,
        }
}</span>

type CreateRoomReq struct {
        ID      string `json:"id"`
        Trainer string `json:"trainer"`
        Trainee string `json:"trainee"`
}

func (h *Handler) CreateRoom(c *gin.Context) <span class="cov0" title="0">{
        var req CreateRoomReq
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                fmt.Println("error")
                return
        }</span>

        <span class="cov0" title="0">h.hub.Rooms[req.ID] = &amp;Room{
                ID:      req.ID,
                Trainer: req.Trainer,
                Trainee: req.Trainee,
                Clients: make(map[string]*Client),
        }

        c.JSON(http.StatusOK, req)</span>
}

var upgrader = websocket.Upgrader{
        ReadBufferSize:  1024,
        WriteBufferSize: 1024,
        CheckOrigin: func(r *http.Request) bool <span class="cov0" title="0">{
                return true
        }</span>,
}

func (h *Handler) JoinRoom(c *gin.Context) <span class="cov0" title="0">{
        conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">roomID := c.Param("roomId")
        username := c.Query("username")

        cl := &amp;Client{
                Conn:     conn,
                Message:  make(chan *Message, 10),
                RoomID:   roomID,
                Username: username,
        }

        m := &amp;Message{
                Content:  "A new user has joined the room",
                RoomID:   roomID,
                Username: username,
        }

        h.hub.Register &lt;- cl
        h.hub.Broadcast &lt;- m

        go cl.writeMessage()
        cl.readMessage(h.hub)</span>
}

type RoomRes struct {
        ID      string `json:"id"`
        Trainer string `json:"trainer"`
        Trainee string `json:"trainee"`
}

func (h *Handler) GetRooms(c *gin.Context) <span class="cov0" title="0">{
        rooms := make([]RoomRes, 0)
        username, err := tokens.ExtractTokenUsername(c)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, rooms)
        }</span>

        <span class="cov0" title="0">for _, r := range h.hub.Rooms </span><span class="cov0" title="0">{
                if r.Trainee == username || r.Trainer == username </span><span class="cov0" title="0">{
                        rooms = append(rooms, RoomRes{
                                ID:      r.ID,
                                Trainer: r.Trainer,
                                Trainee: r.Trainee,
                        })
                }</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, GetRoomsResponse{
                Status: http.StatusOK,
                Rooms:  rooms,
        })</span>
}

type ClientRes struct {
        ID       string `json:"id"`
        Username string `json:"username"`
}

func (h *Handler) GetClients(c *gin.Context) <span class="cov0" title="0">{
        var clients []ClientRes
        roomId := c.Param("roomId")

        // fmt.Println("roomId", roomId)
        // _, f := h.hub.Rooms[roomId]
        // fmt.Println("f", f)

        if _, ok := h.hub.Rooms[roomId]; !ok </span><span class="cov0" title="0">{
                clients = make([]ClientRes, 0)
                c.JSON(http.StatusOK, clients)
        }</span>

        <span class="cov0" title="0">for _, c := range h.hub.Rooms[roomId].Clients </span><span class="cov0" title="0">{
                clients = append(clients, ClientRes{
                        Username: c.Username,
                })
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, clients)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
